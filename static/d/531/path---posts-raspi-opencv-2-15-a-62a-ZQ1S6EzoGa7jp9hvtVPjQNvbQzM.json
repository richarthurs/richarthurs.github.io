{"data":{"logo":{"childImageSharp":{"fixed":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAAC4jAAAuIwF4pT92AAAAf0lEQVQI12P49++f3v///xWBmBuIOYBYigEJQMXEobQ0kpg8EDMxoAOg4HQgzgbiBCB2AeJaIHYE4jAgjgbiFCD2BWI3IG6FymUCcQWUtoWqCwKpARkYBcReQJwF1egBZdcAXQ/ix0MtAmlMB4r5AGkHIA4BskGW5kMdZALESQDh3apPUyViLgAAAABJRU5ErkJggg==","width":400,"height":64,"src":"/static/1642a962a17c5982edb23d2f20e5a8e6/51380/logo.png","srcSet":"/static/1642a962a17c5982edb23d2f20e5a8e6/51380/logo.png 1x,\n/static/1642a962a17c5982edb23d2f20e5a8e6/240c8/logo.png 1.5x,\n/static/1642a962a17c5982edb23d2f20e5a8e6/f5cf3/logo.png 2x,\n/static/1642a962a17c5982edb23d2f20e5a8e6/01d7c/logo.png 3x"}}},"markdownRemark":{"html":"<p>In this second post regarding my experiments with OpenCV on the Raspberry pi, I will go over interfacing the OpenCV code with the Pi’s UART, so that I can send image centroids to the auxiliary MCU that will be used for motor control. These posts will be somewhere between a tutorial and a build log - all steps will be mentioned, but not in great detail.</p>\n<p>Part 1: <a href=\"http://richarthurs.com/2017/08/20/getting-started-with-opencv-and-raspberry-pi/\">http://richarthurs.com/2017/08/20/getting-started-with-opencv-and-raspberry-pi/</a></p>\n<h2>Configuring UART</h2>\n<p>First, follow the instructions here: <a href=\"https://spellfoundry.com/2016/05/29/configuring-gpio-serial-port-raspbian-jessie-including-pi-3/\">https://spellfoundry.com/2016/05/29/configuring-gpio-serial-port-raspbian-jessie-including-pi-3/</a></p>\n<p>I disabled the UART>console connection using the raspi-config (sudo raspi-config), meaning that I didn’t need to manually remove it from the cmdline.txt file.</p>\n<h2>Testing UART</h2>\n<p>On my Pi 3, the UART connected to GPIO 14 and 15 is available at /dev/serial0. On the Pi, run the following commands to install the screen utility and get an instance running.</p>\n<p>sudo apt-get install screen\nscreen /dev/serial0 115200\nIf you short GPIO 14 and 15, you should see the entered characters echoed back on your display. To quit a screen instance on the pi, press escape, then ctrl+a, then \\</p>\n<p>Laptop Test</p>\n<p>I wanted to test out communication to my laptop, so I grabbed a package to install screen. After installing, I connected a 3.3V USB-UART converter, being sure to connect Pi Rx to converter TX, and vice-versa. Also connect a GND line between the Pi and the converter, since they aren’t likely connected to the same power source.</p>\n<p>To find the location of your serial converter on mac or linux, run ls /dev and look for something along the lines of “tty.usbserial-A50285BI.” This is the equivalent of serial0 on the Pi.  Run the following command to start a screen instance:</p>\n<p>screen /dev/<em>your</em>adapter<em>address</em>here 115200</p>\n<p>Assuming you have screen instances running on the Pi and computer simultaneously, you should see characters echoed between the two as you type on either keyboard. I initially forgot to connect a common GND between the two devices, which caused me to only receive on my computer from the Pi, but not from my computer.</p>\n<p>To quit screen on mac or linux, ctrl + a, then :, then “quit” (no quotes).</p>\n<p>PySerial</p>\n<p>PySerial is an excellent and easy to use serial communication library that I’ve used before. We’ll bring it into this project on the Pi, and it can be installed with pip install pyserial. </p>\n<p>I wrote up the following test script and ran it with python serialtest.py.</p>\n<p>import serial\nser = serial.Serial(‘/dev/serial0’, 115200, timeout = 1)\nprint ser.name </p>\n<p>for i in range(0,5,1):\nser.write(str(i))\nser.close()</p>\n<p>After confirming that everything worked as expected, we are now ready to test integration with the rest of the OpenCV code and confirm that the centroid locations are being sent over correctly.</p>\n<p>OpenCV Integration</p>\n<p>Since I was already printing the centroid locations to the terminal, I just needed to replace the print() commands with ser.write() and some internal string formatting to include a return and newline. Running the code and looking at the UART output from the Pi, we can see that it is correctly sending the x,y coordinates of the centroid as I move the camera around.</p>\n<p>Screen output showing centroid locations coming from the Pi over UART</p>\n<p>Next Steps</p>\n<p>Now that serial communication is working and it can be easily integrated with the rest of the OpenCV code, I need to determine if I want to use any sort of protocol between the auxiliary MCU and the Pi. Since I will likely need to send data back and forth, it is probably a good idea to keep everything well defined. More on that in the next post!</p>\n<p>Reviewing the task list in the first post, I’d say I’m about half way through part 3.</p>\n<p>Install and compile OpenCV on the pi\nTrack and find centroid of an object\nSend out obstacle centroid over UART\nIntegrate OpenCV and pySerial\nDetermine message protocol\nGet a simple motor control system on the auxiliary MCU working\nStart developing obstacle avoidance functionality</p>","htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"In this second post regarding my experiments with OpenCV on the Raspberry pi, I will go over interfacing the OpenCV code with the Pi’s UART, so that I can send image centroids to the auxiliary MCU that will be used for motor control. These posts will be somewhere between a tutorial and a build log - all steps will be mentioned, but not in great detail."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Part 1: "},{"type":"element","tagName":"a","properties":{"href":"http://richarthurs.com/2017/08/20/getting-started-with-opencv-and-raspberry-pi/"},"children":[{"type":"text","value":"http://richarthurs.com/2017/08/20/getting-started-with-opencv-and-raspberry-pi/"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Configuring UART"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"First, follow the instructions here: "},{"type":"element","tagName":"a","properties":{"href":"https://spellfoundry.com/2016/05/29/configuring-gpio-serial-port-raspbian-jessie-including-pi-3/"},"children":[{"type":"text","value":"https://spellfoundry.com/2016/05/29/configuring-gpio-serial-port-raspbian-jessie-including-pi-3/"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"I disabled the UART>console connection using the raspi-config (sudo raspi-config), meaning that I didn’t need to manually remove it from the cmdline.txt file."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Testing UART"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"On my Pi 3, the UART connected to GPIO 14 and 15 is available at /dev/serial0. On the Pi, run the following commands to install the screen utility and get an instance running."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"sudo apt-get install screen\nscreen /dev/serial0 115200\nIf you short GPIO 14 and 15, you should see the entered characters echoed back on your display. To quit a screen instance on the pi, press escape, then ctrl+a, then \\"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Laptop Test"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"I wanted to test out communication to my laptop, so I grabbed a package to install screen. After installing, I connected a 3.3V USB-UART converter, being sure to connect Pi Rx to converter TX, and vice-versa. Also connect a GND line between the Pi and the converter, since they aren’t likely connected to the same power source."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"To find the location of your serial converter on mac or linux, run ls /dev and look for something along the lines of “tty.usbserial-A50285BI.” This is the equivalent of serial0 on the Pi.  Run the following command to start a screen instance:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"screen /dev/"},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"your"}]},{"type":"text","value":"adapter"},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"address"}]},{"type":"text","value":"here 115200"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Assuming you have screen instances running on the Pi and computer simultaneously, you should see characters echoed between the two as you type on either keyboard. I initially forgot to connect a common GND between the two devices, which caused me to only receive on my computer from the Pi, but not from my computer."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"To quit screen on mac or linux, ctrl + a, then :, then “quit” (no quotes)."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"PySerial"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"PySerial is an excellent and easy to use serial communication library that I’ve used before. We’ll bring it into this project on the Pi, and it can be installed with pip install pyserial. "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"I wrote up the following test script and ran it with python serialtest.py."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"import serial\nser = serial.Serial(‘/dev/serial0’, 115200, timeout = 1)\nprint ser.name "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"for i in range(0,5,1):\nser.write(str(i))\nser.close()"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"After confirming that everything worked as expected, we are now ready to test integration with the rest of the OpenCV code and confirm that the centroid locations are being sent over correctly."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"OpenCV Integration"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Since I was already printing the centroid locations to the terminal, I just needed to replace the print() commands with ser.write() and some internal string formatting to include a return and newline. Running the code and looking at the UART output from the Pi, we can see that it is correctly sending the x,y coordinates of the centroid as I move the camera around."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Screen output showing centroid locations coming from the Pi over UART"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Next Steps"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Now that serial communication is working and it can be easily integrated with the rest of the OpenCV code, I need to determine if I want to use any sort of protocol between the auxiliary MCU and the Pi. Since I will likely need to send data back and forth, it is probably a good idea to keep everything well defined. More on that in the next post!"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Reviewing the task list in the first post, I’d say I’m about half way through part 3."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Install and compile OpenCV on the pi\nTrack and find centroid of an object\nSend out obstacle centroid over UART\nIntegrate OpenCV and pySerial\nDetermine message protocol\nGet a simple motor control system on the auxiliary MCU working\nStart developing obstacle avoidance functionality"}]}],"data":{"quirksMode":false}},"excerpt":"In this second post regarding my experiments with OpenCV on the Raspberry pi, I will go over interfacing the OpenCV code with the Pi’s UART…","timeToRead":3,"frontmatter":{"title":"Raspberry Pi & OpenCV - UART Communication (Part 2)","userDate":"22 August 2017","date":"2017-08-22T00:00:00.000Z","tags":["openCV","camera","raspberry pi","UART","linux","embedded","Blog-post"],"image":{"childImageSharp":{"fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAMEAv/EABYBAQEBAAAAAAAAAAAAAAAAAAEAAv/aAAwDAQACEAMQAAABW2icMFZa/8QAGxAAAwACAwAAAAAAAAAAAAAAAQIRAAMhIiP/2gAIAQEAAQUCNQNwokdu2tvSDP/EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABcRAQADAAAAAAAAAAAAAAAAAAABITH/2gAIAQIBAT8BjVP/xAAdEAACAgEFAAAAAAAAAAAAAAAAAQIRMQMhMlGh/9oACAEBAAY/AjdtI5C01mXhKF2l2YP/xAAcEAACAgIDAAAAAAAAAAAAAAABEQAxIUFRcYH/2gAIAQEAAT8hFVMk3FaSbAjhy9mTFs4Q3YS0LKT/2gAMAwEAAgADAAAAENcP/8QAFxEAAwEAAAAAAAAAAAAAAAAAAAERMf/aAAgBAwEBPxCahVH/xAAXEQEBAQEAAAAAAAAAAAAAAAABABEh/9oACAECAQE/EONSJ2//xAAeEAEAAgIBBQAAAAAAAAAAAAABABEhQWExUXGh0f/aAAgBAQABPxAeWElc+JWHJGgjWCXm/HUZnIbe5yyn7hsKWr7anwGf/9k=","aspectRatio":1.3711151736745886,"src":"/static/f15fa1d1a24a28241d8b82bb79098cc9/d348a/raspi-opencv-2-1.jpg","srcSet":"/static/f15fa1d1a24a28241d8b82bb79098cc9/7e9f5/raspi-opencv-2-1.jpg 930w,\n/static/f15fa1d1a24a28241d8b82bb79098cc9/d348a/raspi-opencv-2-1.jpg 1500w","sizes":"(max-width: 1500px) 100vw, 1500px"}}},"author":{"id":"Richard","bio":"Mechatronics Systems engineering student passionate about space, interested in high-reliability embedded systems and computer vision. Currently turning coffee into CubeSats and drones.","avatar":{"children":[{"__typename":"ImageSharp","fixed":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAIDBAX/xAAVAQEBAAAAAAAAAAAAAAAAAAABAP/aAAwDAQACEAMQAAAB589OeKWwkKgbQn//xAAbEAACAwADAAAAAAAAAAAAAAABAgASIREiMf/aAAgBAQABBQKE9YzUFt5h1V0n3//EABURAQEAAAAAAAAAAAAAAAAAAAEQ/9oACAEDAQE/ASE//8QAFREBAQAAAAAAAAAAAAAAAAAAESD/2gAIAQIBAT8BY//EABoQAAICAwAAAAAAAAAAAAAAAAABESEQIDH/2gAIAQEABj8CFHcUrJ1//8QAGhABAAMBAQEAAAAAAAAAAAAAAQARIUExEP/aAAgBAQABPyG1c2E0Ipg9xPQFJ35HtxipKNj1P//aAAwDAQACAAMAAAAQkxCD/8QAGBEAAgMAAAAAAAAAAAAAAAAAABEBECH/2gAIAQMBAT8Q0xkK/8QAGBEAAgMAAAAAAAAAAAAAAAAAAAEQEUH/2gAIAQIBAT8Qs4WiP//EABwQAQADAAMBAQAAAAAAAAAAAAEAESExQXFhkf/aAAgBAQABPxCgAp6NYEcIGjV7i+0/kFpV61wTiYFlNYhBTUGAHzHlQFSFqER9qn//2Q==","width":400,"height":400,"src":"/static/a2b7322425489e49016cd6942dbb87ef/2e811/richard.jpg","srcSet":"/static/a2b7322425489e49016cd6942dbb87ef/2e811/richard.jpg 1x"}}]}}}},"relatedPosts":{"totalCount":1,"edges":[{"node":{"id":"b1845f0b-7205-57c5-a42a-d10860c2dd4b","timeToRead":3,"excerpt":"In this second post regarding my experiments with OpenCV on the Raspberry pi, I will go over interfacing the OpenCV code with the Pi’s UART…","frontmatter":{"title":"Raspberry Pi & OpenCV - UART Communication (Part 2)"},"fields":{"slug":"/posts/raspi-opencv-2/"}}}]}},"pageContext":{"slug":"/posts/raspi-opencv-2/","prev":{"excerpt":"At the SFU Satellite Design Team, we are taking part in the Canadian Satellite Design Challenge. As part of the challenge, we were offered…","timeToRead":6,"frontmatter":{"title":"Radiation Testing a CubeSat Computer","tags":["CubeSat","Radiation","SEL","OBC","SFUSat","Blog-post"],"date":"2017-09-23T00:00:00.000Z","image":{"childImageSharp":{"fluid":{"aspectRatio":1.778642936596218,"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAQBAwX/xAAVAQEBAAAAAAAAAAAAAAAAAAABAP/aAAwDAQACEAMQAAABi3NaJsUB/8QAGhABAQACAwAAAAAAAAAAAAAAAQIAAxESIv/aAAgBAQABBQKECa755zU81rpMqlr/xAAVEQEBAAAAAAAAAAAAAAAAAAAAEf/aAAgBAwEBPwFX/8QAFxEAAwEAAAAAAAAAAAAAAAAAABESIf/aAAgBAgEBPwFLST//xAAaEAACAgMAAAAAAAAAAAAAAAAAARExAhAh/9oACAEBAAY/AlLOFvWUFn//xAAaEAEBAQEAAwAAAAAAAAAAAAABEQAhMUFh/9oACAEBAAE/IThuG8SnmICq/eZFr7m6BI68Vv/aAAwDAQACAAMAAAAQ9O//xAAWEQEBAQAAAAAAAAAAAAAAAAARARD/2gAIAQMBAT8QWkx//8QAFxEBAQEBAAAAAAAAAAAAAAAAAQARIf/aAAgBAgEBPxBAVGu3/8QAHRABAQACAQUAAAAAAAAAAAAAAREAMUEhUYGRsf/aAAgBAQABPxC5JZ2znL2uUgBtkO+QRQ67PWHLJPguNpVEnE1jRZh8M//Z","sizes":"(max-width: 1599px) 100vw, 1599px","src":"/static/de178e6f5465ab050ebae7d1711e2130/2f7ed/triumf-1.jpg","srcSet":"/static/de178e6f5465ab050ebae7d1711e2130/ddd93/triumf-1.jpg 930w,\n/static/de178e6f5465ab050ebae7d1711e2130/2f7ed/triumf-1.jpg 1599w"}}},"author":{"id":"Richard","bio":"Mechatronics Systems engineering student passionate about space, interested in high-reliability embedded systems and computer vision. Currently turning coffee into CubeSats and drones.","avatar":{"children":[{"fixed":{"src":"/static/a2b7322425489e49016cd6942dbb87ef/2e811/richard.jpg"}}]}}},"fields":{"layout":"","slug":"/posts/radiation-testing-cubesat-computer/"}},"next":null,"primaryTag":"openCV"}}