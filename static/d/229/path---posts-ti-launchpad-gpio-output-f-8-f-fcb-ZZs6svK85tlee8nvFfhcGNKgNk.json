{"data":{"logo":{"childImageSharp":{"fixed":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAAC4jAAAuIwF4pT92AAAAf0lEQVQI12P49++f3v///xWBmBuIOYBYigEJQMXEobQ0kpg8EDMxoAOg4HQgzgbiBCB2AeJaIHYE4jAgjgbiFCD2BWI3IG6FymUCcQWUtoWqCwKpARkYBcReQJwF1egBZdcAXQ/ix0MtAmlMB4r5AGkHIA4BskGW5kMdZALESQDh3apPUyViLgAAAABJRU5ErkJggg==","width":400,"height":64,"src":"/static/1642a962a17c5982edb23d2f20e5a8e6/51380/logo.png","srcSet":"/static/1642a962a17c5982edb23d2f20e5a8e6/51380/logo.png 1x,\n/static/1642a962a17c5982edb23d2f20e5a8e6/240c8/logo.png 1.5x,\n/static/1642a962a17c5982edb23d2f20e5a8e6/f5cf3/logo.png 2x,\n/static/1642a962a17c5982edb23d2f20e5a8e6/01d7c/logo.png 3x"}}},"markdownRemark":{"html":"<p>The GPIO functions in Tivaware take a little fiddling with to understand. For beginners, it may not be immediately obvious what’s going on in the output function, especially as there are multiple ways to do the same thing. Let’s take a look at an example of how to use the pins, and at the end we’ll set them up (that’s the boring part).</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">GPIOPinWrite(GPIO_PORTF_BASE,GPIO_PIN_1, GPIO_PIN_1);\t// turn on one LED</code></pre></div>\n<p>Tivaware includes the GPIOPinWrite function. As arguments, it takes the base port, the pin(s) and the value to write. So to write to PF1, we need to tell it that we’re in port F, we want pin 1, and then the value. The ‘value’ isn’t a 1 or a zero, however. It needs to be a 1 or a 0 in the position of the pin we want to control, that’s the key. GPIO<em>PIN</em>1 is simply a variable equal to the position of pin 1 in registers, which is actually equal to 2 in decimal notation. You can see the number that these macros are referencing by hovering your mouse over them in Code Composer Studio. Pin 1 = 2, Pin 2 = 4, Pin 3 = 8, and so on.</p>\n<p>So we are telling the microcontroller to place a 1 in the 2’s place, which corresponds to pin 1 on port F. How confusing is that?! It’s not too bad, but it can take a little while to wrap your head around if you’re coming straight from Arduino. If you’ve dealt with 8-bit microcontroller programming, this won’t be too bad, since there are only 8 pins on a port here too.</p>\n<h3>Multiple pins at once</h3>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">GPIOPinWrite(GPIO_PORTF_BASE,GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3, 4);\t// turn on one LED</code></pre></div>\n<p>To set multiple pins at the same time, we need to do two things. As before, we’re specifying that we’re on port F. First, we’ll OR the pins we need together. The pipe character ”|” means OR. So the micro is going to be able to work with any pins we specify here in a string of OR statements. In that case, it’s pins 1, 2, and 3. It’s not a big deal if we put a pin in here that we don’t end up setting.</p>\n<p>Next up, we set the value. Remember how each GPIO<em>PIN</em>X is actually a number? Since we’ve placed a 4 here, that corresponds to pin F2. Since pin F2 was specified in our ORing earlier, F4 will go high. Instead of placing a 4, we could’ve also put GPIO<em>PIN</em>2, like in the previous example, which is equal to 4.</p>\n<p>So how do we set multiple pins? First, they need to appear in your OR statement. Then, we set the port to equal the addresses of those pins, but added together. Since pin 1 = 2, pin 2 = 4, and pin 3 = 8, we could set the port to 6, 10, 12, or 14. These are all the combinations of adding 2, 4, and 8 to each other. This is how the GPIO bus works, there’s a unique number for any combination of pins being on. Tivaware handles this automatically, so we can just change the pins we want, and the others will keep their states. Awesome!</p>\n<p>This numbering system could get confusing since we won’t always remember which number corresponds to each pin. Luckily, we can use the OR statement again. In an application like this, OR is actually serving as addition. If we OR 00000010 with 00000100 (2 and 4 in binary), we get 00000110. See, from our two inputs, we’ve set any bit that input 1 OR input 2 have set. To do this with Tivaware, we can set the last argument of our function as GPIO<em>PIN</em>2|GPIO<em>PIN</em>3, for example. This will turn on pins 1 and 3. We could’ve even set it to 4|8, which is kind of weird, but is what the GPIO<em>PIN</em>X variables represent. Here’s an example:</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">GPIOPinWrite(GPIO_PORTF_BASE,GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3, GPIO_PIN_2|GPIO_PIN_3);\t// turn on two LEDs</code></pre></div>\n<h3>Turning pins off</h3>\n<p>To turn a pin off, simply put its address in the second argument of GPIOPinWrite and write a zero as the third argument. Actually, anything except the pin’s address will make turn it off. There is an example of this in the complete demo code at the end, where we turn off pin 1 only.</p>\n<h3>Setting up outputs</h3>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);\t// enable port F\n\nGPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3);\t// enable outputs on the launchpad LED pins</code></pre></div>\n<p>To set pins as outputs, we just need to enable the port and set some pins as outputs. Like we’ve gone through, we OR together the specific pins we’d like to mess with. There are also includes above this. They’re in the complete demo code below. This program will blink a few of the LEDs on the launchpad. It’s a good example of how to set single and multiple pins, and turn specific pins off.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">/*\nGPIO Output Demo\n*/\n\n#include &lt;stdint.h&gt;\n#include &lt;stdbool.h&gt;\n#include &quot;inc/hw_types.h&quot;\n#include &quot;inc/hw_memmap.h&quot;\n#include &quot;driverlib/sysctl.h&quot;\n#include &quot;driverlib/gpio.h&quot;\nint main(void)\n{\n  SysCtlClockSet(SYSCTL_SYSDIV_4|SYSCTL_USE_PLL|SYSCTL_XTAL_16MHZ|SYSCTL_OSC_MAIN);\t// set up the clock\n  SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);\t// enable port F\n  GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3);\t// enable outputs on the launchpad LED pins\n\n  while(1)\n  {\n\n      GPIOPinWrite(GPIO_PORTF_BASE,GPIO_PIN_1, GPIO_PIN_1);\t// turn on one LED\n      SysCtlDelay(7000000); // wait a while\n      GPIOPinWrite(GPIO_PORTF_BASE,GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3, GPIO_PIN_1|GPIO_PIN_2);\t// turn on two LEDs\n      SysCtlDelay(7000000);\n      GPIOPinWrite(GPIO_PORTF_BASE,GPIO_PIN_1, 0x00);\t// turn pin 1 off\n      SysCtlDelay(7000000);\n  }\n}</code></pre></div>","htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The GPIO functions in Tivaware take a little fiddling with to understand. For beginners, it may not be immediately obvious what’s going on in the output function, especially as there are multiple ways to do the same thing. Let’s take a look at an example of how to use the pins, and at the end we’ll set them up (that’s the boring part)."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"c"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-c"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-c"]},"children":[{"type":"text","value":"GPIOPinWrite(GPIO_PORTF_BASE,GPIO_PIN_1, GPIO_PIN_1);\t// turn on one LED"}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Tivaware includes the GPIOPinWrite function. As arguments, it takes the base port, the pin(s) and the value to write. So to write to PF1, we need to tell it that we’re in port F, we want pin 1, and then the value. The ‘value’ isn’t a 1 or a zero, however. It needs to be a 1 or a 0 in the position of the pin we want to control, that’s the key. GPIO"},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"PIN"}]},{"type":"text","value":"1 is simply a variable equal to the position of pin 1 in registers, which is actually equal to 2 in decimal notation. You can see the number that these macros are referencing by hovering your mouse over them in Code Composer Studio. Pin 1 = 2, Pin 2 = 4, Pin 3 = 8, and so on."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"So we are telling the microcontroller to place a 1 in the 2’s place, which corresponds to pin 1 on port F. How confusing is that?! It’s not too bad, but it can take a little while to wrap your head around if you’re coming straight from Arduino. If you’ve dealt with 8-bit microcontroller programming, this won’t be too bad, since there are only 8 pins on a port here too."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Multiple pins at once"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"c"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-c"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-c"]},"children":[{"type":"text","value":"GPIOPinWrite(GPIO_PORTF_BASE,GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3, 4);\t// turn on one LED"}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"To set multiple pins at the same time, we need to do two things. As before, we’re specifying that we’re on port F. First, we’ll OR the pins we need together. The pipe character ”|” means OR. So the micro is going to be able to work with any pins we specify here in a string of OR statements. In that case, it’s pins 1, 2, and 3. It’s not a big deal if we put a pin in here that we don’t end up setting."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Next up, we set the value. Remember how each GPIO"},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"PIN"}]},{"type":"text","value":"X is actually a number? Since we’ve placed a 4 here, that corresponds to pin F2. Since pin F2 was specified in our ORing earlier, F4 will go high. Instead of placing a 4, we could’ve also put GPIO"},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"PIN"}]},{"type":"text","value":"2, like in the previous example, which is equal to 4."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"So how do we set multiple pins? First, they need to appear in your OR statement. Then, we set the port to equal the addresses of those pins, but added together. Since pin 1 = 2, pin 2 = 4, and pin 3 = 8, we could set the port to 6, 10, 12, or 14. These are all the combinations of adding 2, 4, and 8 to each other. This is how the GPIO bus works, there’s a unique number for any combination of pins being on. Tivaware handles this automatically, so we can just change the pins we want, and the others will keep their states. Awesome!"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"This numbering system could get confusing since we won’t always remember which number corresponds to each pin. Luckily, we can use the OR statement again. In an application like this, OR is actually serving as addition. If we OR 00000010 with 00000100 (2 and 4 in binary), we get 00000110. See, from our two inputs, we’ve set any bit that input 1 OR input 2 have set. To do this with Tivaware, we can set the last argument of our function as GPIO"},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"PIN"}]},{"type":"text","value":"2|GPIO"},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"PIN"}]},{"type":"text","value":"3, for example. This will turn on pins 1 and 3. We could’ve even set it to 4|8, which is kind of weird, but is what the GPIO"},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"PIN"}]},{"type":"text","value":"X variables represent. Here’s an example:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"c"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-c"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-c"]},"children":[{"type":"text","value":"GPIOPinWrite(GPIO_PORTF_BASE,GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3, GPIO_PIN_2|GPIO_PIN_3);\t// turn on two LEDs"}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Turning pins off"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"To turn a pin off, simply put its address in the second argument of GPIOPinWrite and write a zero as the third argument. Actually, anything except the pin’s address will make turn it off. There is an example of this in the complete demo code at the end, where we turn off pin 1 only."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Setting up outputs"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"c"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-c"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-c"]},"children":[{"type":"text","value":"SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);\t// enable port F\n\nGPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3);\t// enable outputs on the launchpad LED pins"}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"To set pins as outputs, we just need to enable the port and set some pins as outputs. Like we’ve gone through, we OR together the specific pins we’d like to mess with. There are also includes above this. They’re in the complete demo code below. This program will blink a few of the LEDs on the launchpad. It’s a good example of how to set single and multiple pins, and turn specific pins off."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"c"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-c"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-c"]},"children":[{"type":"text","value":"/*\nGPIO Output Demo\n*/\n\n#include <stdint.h>\n#include <stdbool.h>\n#include \"inc/hw_types.h\"\n#include \"inc/hw_memmap.h\"\n#include \"driverlib/sysctl.h\"\n#include \"driverlib/gpio.h\"\nint main(void)\n{\n  SysCtlClockSet(SYSCTL_SYSDIV_4|SYSCTL_USE_PLL|SYSCTL_XTAL_16MHZ|SYSCTL_OSC_MAIN);\t// set up the clock\n  SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);\t// enable port F\n  GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3);\t// enable outputs on the launchpad LED pins\n\n  while(1)\n  {\n\n      GPIOPinWrite(GPIO_PORTF_BASE,GPIO_PIN_1, GPIO_PIN_1);\t// turn on one LED\n      SysCtlDelay(7000000); // wait a while\n      GPIOPinWrite(GPIO_PORTF_BASE,GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3, GPIO_PIN_1|GPIO_PIN_2);\t// turn on two LEDs\n      SysCtlDelay(7000000);\n      GPIOPinWrite(GPIO_PORTF_BASE,GPIO_PIN_1, 0x00);\t// turn pin 1 off\n      SysCtlDelay(7000000);\n  }\n}"}]}]}]}],"data":{"quirksMode":false}},"excerpt":"The GPIO functions in Tivaware take a little fiddling with to understand. For beginners, it may not be immediately obvious what’s going on…","timeToRead":4,"frontmatter":{"title":"TI ARM LaunchPad GPIO Output Tutorial","userDate":"25 May 2015","date":"2015-05-25T00:00:00.000Z","tags":["microcontroller","TI","ARM","tutorial","Blog-post"],"image":{"childImageSharp":{"fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAQCA//EABYBAQEBAAAAAAAAAAAAAAAAAAQABf/aAAwDAQACEAMQAAABj1xTLEB2f//EABsQAAEEAwAAAAAAAAAAAAAAAAEAAgMRIUFC/9oACAEBAAEFAusU5sS0Lolf/8QAGBEAAwEBAAAAAAAAAAAAAAAAAAIRAzL/2gAIAQMBAT8Bg2TXo//EABgRAAMBAQAAAAAAAAAAAAAAAAABAhED/9oACAECAQE/AYePRdZP/8QAGRAAAgMBAAAAAAAAAAAAAAAAAAEQISNB/9oACAEBAAY/AqhacEXH/8QAGBAAAwEBAAAAAAAAAAAAAAAAAAERMUH/2gAIAQEAAT8hfVJPBKjWk3bRSlDVknh//9oADAMBAAIAAwAAABA7D//EABoRAAICAwAAAAAAAAAAAAAAAAABESExgaH/2gAIAQMBAT8QeCjZI24f/8QAGREAAwADAAAAAAAAAAAAAAAAAAERMaHR/9oACAECAQE/EE0EGXrh/8QAGxABAAMBAAMAAAAAAAAAAAAAAQARITFBcaH/2gAIAQEAAT8QfatgfkpxTEvIC1CLg7bFWDT4iFoL9QhG2T//2Q==","aspectRatio":1.3333333333333333,"src":"/static/499f888b5cc05de8f7dbe315803ec5ff/b326b/tiva-launchpad-header-3.jpg","srcSet":"/static/499f888b5cc05de8f7dbe315803ec5ff/4018e/tiva-launchpad-header-3.jpg 930w,\n/static/499f888b5cc05de8f7dbe315803ec5ff/88222/tiva-launchpad-header-3.jpg 1860w,\n/static/499f888b5cc05de8f7dbe315803ec5ff/b326b/tiva-launchpad-header-3.jpg 3264w","sizes":"(max-width: 3264px) 100vw, 3264px"}}},"author":{"id":"Richard","bio":"Mechatronics Systems engineering student passionate about space, interested in high-reliability embedded systems and computer vision. Currently turning coffee into CubeSats and drones.","avatar":{"children":[{"__typename":"ImageSharp","fixed":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAIDBAX/xAAVAQEBAAAAAAAAAAAAAAAAAAABAP/aAAwDAQACEAMQAAAB589OeKWwkKgbQn//xAAbEAACAwADAAAAAAAAAAAAAAABAgASIREiMf/aAAgBAQABBQKE9YzUFt5h1V0n3//EABURAQEAAAAAAAAAAAAAAAAAAAEQ/9oACAEDAQE/ASE//8QAFREBAQAAAAAAAAAAAAAAAAAAESD/2gAIAQIBAT8BY//EABoQAAICAwAAAAAAAAAAAAAAAAABESEQIDH/2gAIAQEABj8CFHcUrJ1//8QAGhABAAMBAQEAAAAAAAAAAAAAAQARIUExEP/aAAgBAQABPyG1c2E0Ipg9xPQFJ35HtxipKNj1P//aAAwDAQACAAMAAAAQkxCD/8QAGBEAAgMAAAAAAAAAAAAAAAAAABEBECH/2gAIAQMBAT8Q0xkK/8QAGBEAAgMAAAAAAAAAAAAAAAAAAAEQEUH/2gAIAQIBAT8Qs4WiP//EABwQAQADAAMBAQAAAAAAAAAAAAEAESExQXFhkf/aAAgBAQABPxCgAp6NYEcIGjV7i+0/kFpV61wTiYFlNYhBTUGAHzHlQFSFqER9qn//2Q==","width":400,"height":400,"src":"/static/a2b7322425489e49016cd6942dbb87ef/2e811/richard.jpg","srcSet":"/static/a2b7322425489e49016cd6942dbb87ef/2e811/richard.jpg 1x"}}]}}}},"relatedPosts":{"totalCount":3,"edges":[{"node":{"id":"9c280710-4b19-5dea-ae81-49819aaf7458","timeToRead":3,"excerpt":"TI locks some GPIO pins because they’re required for programming interfaces like JTAG. SW2 on the LaunchPad is connected to PF0 ( page 33…","frontmatter":{"title":"TI ARM LaunchPad GPIO Unlock Tutorial"},"fields":{"slug":"/posts/ti-launchpad-gpio-unlock/"}}},{"node":{"id":"62dce9aa-62b4-5e97-8eb6-2fefc7ea5017","timeToRead":6,"excerpt":"The TI Tiva Launchpad boards are an excellent way to get started working with ARM microcontrollers. With the Tivaware software suite, they…","frontmatter":{"title":"TI ARM LaunchPad GPIO Input Tutorial"},"fields":{"slug":"/posts/ti-launchpad-gpio-input/"}}},{"node":{"id":"02856b9a-5f4b-54b2-9e79-e36fa544eb9c","timeToRead":4,"excerpt":"The GPIO functions in Tivaware take a little fiddling with to understand. For beginners, it may not be immediately obvious what’s going on…","frontmatter":{"title":"TI ARM LaunchPad GPIO Output Tutorial"},"fields":{"slug":"/posts/ti-launchpad-gpio-output/"}}}]}},"pageContext":{"slug":"/posts/ti-launchpad-gpio-output/","prev":{"excerpt":"The TI Tiva Launchpad boards are an excellent way to get started working with ARM microcontrollers. With the Tivaware software suite, they…","timeToRead":6,"frontmatter":{"title":"TI ARM LaunchPad GPIO Input Tutorial","tags":["microcontroller","TI","ARM","tutorial","Blog-post"],"date":"2015-05-25T00:00:00.000Z","image":{"childImageSharp":{"fluid":{"aspectRatio":1.3333333333333333,"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAwACBf/EABUBAQEAAAAAAAAAAAAAAAAAAAME/9oADAMBAAIQAxAAAAHmKhVqNiIf/8QAGRAAAwEBAQAAAAAAAAAAAAAAAAECEQMS/9oACAEBAAEFAp5ukoNFqn0kOj//xAAWEQEBAQAAAAAAAAAAAAAAAAACEEH/2gAIAQMBAT8BIOz/xAAYEQACAwAAAAAAAAAAAAAAAAACAxARMf/aAAgBAgEBPwFp3kf/xAAaEAACAgMAAAAAAAAAAAAAAAABEABBAhEh/9oACAEBAAY/At1OFHKn/8QAGBABAQEBAQAAAAAAAAAAAAAAAREAITH/2gAIAQEAAT8hjchnXVGFDMsQ1BmrFmRfN//aAAwDAQACAAMAAAAQdx//xAAYEQEBAAMAAAAAAAAAAAAAAAABABEhwf/aAAgBAwEBPxARh8kB03//xAAXEQEBAQEAAAAAAAAAAAAAAAABACFB/9oACAECAQE/EBNzpf/EABsQAQEAAwADAAAAAAAAAAAAAAERACExUXHB/9oACAEBAAE/EGMFBC313DC7mdV+YrJJ57hMGYE7HBfCt0buFoACAHM//9k=","sizes":"(max-width: 3264px) 100vw, 3264px","src":"/static/1a3dc0006a5adae718d145990e724821/b326b/tiva-launchpad-header.jpg","srcSet":"/static/1a3dc0006a5adae718d145990e724821/4018e/tiva-launchpad-header.jpg 930w,\n/static/1a3dc0006a5adae718d145990e724821/88222/tiva-launchpad-header.jpg 1860w,\n/static/1a3dc0006a5adae718d145990e724821/b326b/tiva-launchpad-header.jpg 3264w"}}},"author":{"id":"Richard","bio":"Mechatronics Systems engineering student passionate about space, interested in high-reliability embedded systems and computer vision. Currently turning coffee into CubeSats and drones.","avatar":{"children":[{"fixed":{"src":"/static/a2b7322425489e49016cd6942dbb87ef/2e811/richard.jpg"}}]}}},"fields":{"layout":"","slug":"/posts/ti-launchpad-gpio-input/"}},"next":{"excerpt":"This post contains notes that I generated while bringing up Petalinux on my Cora Z7-10 Zynq board. First I get Petalinux working and do a…","timeToRead":11,"frontmatter":{"title":"Petalinux Bringup on Cora Z7-10 Zynq Board","tags":["FPGA","Zynq","Embedded","Linux","Blog-post"],"date":"2019-01-05T00:00:00.000Z","image":{"childImageSharp":{"fluid":{"aspectRatio":1.3218770654329148,"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAIDBP/EABYBAQEBAAAAAAAAAAAAAAAAAAMCBP/aAAwDAQACEAMQAAABzyi2lYihT//EABsQAAMAAgMAAAAAAAAAAAAAAAACAwEEEBES/9oACAEBAAEFAsbFKDWY7Jv5GfDcf//EABcRAAMBAAAAAAAAAAAAAAAAAAABESH/2gAIAQMBAT8ByFZ//8QAFxEAAwEAAAAAAAAAAAAAAAAAAAEREv/aAAgBAgEBPwGRU2z/xAAcEAABBAMBAAAAAAAAAAAAAAABAAIQUREhgTL/2gAIAQEABj8CyQzoXlvBFiloR//EABsQAQACAgMAAAAAAAAAAAAAAAEAESFhEDFR/9oACAEBAAE/IUlSiLOzrRwv5NiKoB4TE//aAAwDAQACAAMAAAAQlD//xAAYEQACAwAAAAAAAAAAAAAAAAAAASExYf/aAAgBAwEBPxBJLSbH/8QAFhEBAQEAAAAAAAAAAAAAAAAAAEFh/9oACAECAQE/EKTR/8QAHxABAAIBAwUAAAAAAAAAAAAAAQARITFBUWFxgcHh/9oACAEBAAE/EBIFCij0mGzAv0Yp4jDVbbofIyF1BcG+d/MUNAvdn//Z","sizes":"(max-width: 2000px) 100vw, 2000px","src":"/static/9372cc92bbf5a88c049d7549f7f9443f/11c05/blinky-2.jpg","srcSet":"/static/9372cc92bbf5a88c049d7549f7f9443f/d913c/blinky-2.jpg 930w,\n/static/9372cc92bbf5a88c049d7549f7f9443f/4be77/blinky-2.jpg 1860w,\n/static/9372cc92bbf5a88c049d7549f7f9443f/11c05/blinky-2.jpg 2000w"}}},"author":{"id":"Richard","bio":"Mechatronics Systems engineering student passionate about space, interested in high-reliability embedded systems and computer vision. Currently turning coffee into CubeSats and drones.","avatar":{"children":[{"fixed":{"src":"/static/a2b7322425489e49016cd6942dbb87ef/2e811/richard.jpg"}}]}}},"fields":{"layout":"","slug":"/posts/cora-linux-getting-started/"}},"primaryTag":"microcontroller"}}