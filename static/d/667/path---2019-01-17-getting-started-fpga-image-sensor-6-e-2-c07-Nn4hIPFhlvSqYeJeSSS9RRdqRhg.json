{"data":{"logo":{"childImageSharp":{"fixed":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAAC4jAAAuIwF4pT92AAAAf0lEQVQI12P49++f3v///xWBmBuIOYBYigEJQMXEobQ0kpg8EDMxoAOg4HQgzgbiBCB2AeJaIHYE4jAgjgbiFCD2BWI3IG6FymUCcQWUtoWqCwKpARkYBcReQJwF1egBZdcAXQ/ix0MtAmlMB4r5AGkHIA4BskGW5kMdZALESQDh3apPUyViLgAAAABJRU5ErkJggg==","width":400,"height":64,"src":"/static/1642a962a17c5982edb23d2f20e5a8e6/51380/logo.png","srcSet":"/static/1642a962a17c5982edb23d2f20e5a8e6/51380/logo.png 1x,\n/static/1642a962a17c5982edb23d2f20e5a8e6/240c8/logo.png 1.5x,\n/static/1642a962a17c5982edb23d2f20e5a8e6/f5cf3/logo.png 2x,\n/static/1642a962a17c5982edb23d2f20e5a8e6/01d7c/logo.png 3x"}}},"markdownRemark":{"html":"<p>Note: this post is still a work in progress.</p>\n<h2>Steps</h2>\n<ul>\n<li>add an AXI IIC block to the design and run automation</li>\n<li>run synthesis and generate the bitstream</li>\n</ul>\n<h2>Image Sensor Bringup</h2>\n<p>As a sanity check that the image sensor is working, let’s integrate an AXI i2c peripheral and make sure we can snag the camera sensor ID values. We will write some firmware to run on the PS (Zynq speak for the ARM cores). Here are the general steps to follow:</p>\n<ul>\n<li>Make a new block design with the Zynq PS included.</li>\n<li>Add an AXI IIC (Xilinx for I2C) block and run automation.</li>\n<li>create a quick block to generate an <code class=\"language-text\">xclk</code> signal for the image sensor. I just divided my main clock by 4 to hit 12.5 MHz.</li>\n<li>I tweaked the IO pins of the I2C block to use some pins on my board that are unencumbered by pullup resistors. The ArduCam module and the Cora board that I’m using both try to be helpful by including the I2C pullup resistors, but I don’t want any pull issues so I will rely on just the ones on the camera module. </li>\n<li>Ensure the I2C block is seen by the Zynq. You may need to go into the Zynq block and enable it after it’s added to the block diagram. </li>\n<li>Generate bitstream and export hardware to SDK. </li>\n</ul>\n<h3>Firmware</h3>\n<p>I created a new board support package. Assuming the block design is set up correctly, the BSP will include the Xilinx IIC (I2C) driver code. Then it’s time to look at the example code provided by the I2C driver to get the basic usage pattern down. </p>\n<p>Examples are located in <code class=\"language-text\">TODO FILE PATH</code> for me. </p>\n<h3>A Few Gotchas</h3>\n<p>It took a little while to get the sensor talking. Here were some of the things I overlooked. </p>\n<ul>\n<li>\n<p>The camera sensor needs <code class=\"language-text\">xclk</code> to begin replying over I2C. This became obvious after looking at the camera module pinout and wondering what <code class=\"language-text\">xclk</code> was for.</p>\n</li>\n<li>\n<p>The device IDs in the OV2640 datasheet are in hex! And they include the read/write bit. The read/write bit part was obvious in that two addresses were given, the radix was not obvious. It seems that Omnivision uses hex by default in their datasheets, without a <code class=\"language-text\">0x</code> prefix or an <code class=\"language-text\">h</code> to be seen. </p>\n<p>I only uncovered this after blasting requests to all possible I2C addresses and using a logic analyzer to find the <code class=\"language-text\">ACK</code>. </p>\n<p>Note that the Xilinx I2C drivers will add a read/write bit accordingly, so only supply the 7-bit address and make sure the radix is correct. For my <code class=\"language-text\">OV2640</code>, this is <code class=\"language-text\">0x60</code> or <code class=\"language-text\">96</code>. </p>\n</li>\n<li>\n<p>Despite what the datasheet says, the OV2640 seems to have 2 options for the product ID - <code class=\"language-text\">0x42</code> or <code class=\"language-text\">0x41</code>. I get <code class=\"language-text\">0x42</code> but <code class=\"language-text\">0x41</code> is in the datasheet. Given that I can read/write other registers and the <a href=\"https://github.com/ArduCAM/Arduino/blob/13aacea9b01540218e9ba38259f1ffa3a16383f9/ArduCAM/examples/RaspberryPi/arducam_ov2640_capture.cpp\">ArduCam driver</a> also lists these, it’s clearly not a problem. </p>\n</li>\n</ul>\n<p>Slave addr = 60 write\n61 read</p>\n<p>COM10 [4] will set the positive edge of pclk as the active edge</p>\n<h4>Register Set 1</h4>\n<p>Register FF controls which register page is accessable. When register FF is 0x00, the addresses do this:\nReg F7 = slave ID\nMCU in the camera has BIST. </p>\n<h4>Register Set 2</h4>\n<p>When register FF equals 0x01\n0A = product ID number (PIDH)\n0B = product ID number (PIDL)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Set device addr = 60 write\nWrite 01 to FF \n\nRead (61) from 0x0A\nRead (61) from 0x0B</code></pre></div>\n<h2>Designing the Camera Interface Core</h2>\n<p>There are several clocks in this design. </p>\n<ol>\n<li>clk - the main system clock </li>\n<li>xclk - generated by the FPGA from the main clock, fed to the image sensor</li>\n<li>vclk - output from the camera, this is what the video stream is synchronized to</li>\n</ol>\n<p>Therefore, we have some clock domain crossing to handle. First, we need to transition from the vclk domain into the clk domain. This occurs when we load in a pixel from the camera (synchronized to vclk), and need to handle it within the FPGA (the exent of the ‘handling’ changes). </p>\n<p>How can we handle this? Let’s look at <a href=\"https://zipcpu.com/blog/2017/10/20/cdc.html\">some examples</a>. </p>\n<h2>A few Good Links</h2>\n<p><a href=\"http://embeddedprogrammer.blogspot.com/2012/07/hacking-ov7670-camera-module-sccb-cheat.html\">http://embeddedprogrammer.blogspot.com/2012/07/hacking-ov7670-camera-module-sccb-cheat.html</a>\n<a href=\"http://www.arducam.com/products/camera-breakout-board/2mp-ov2640/\">http://www.arducam.com/products/camera-breakout-board/2mp-ov2640/</a></p>","htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Note: this post is still a work in progress."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Steps"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"add an AXI IIC block to the design and run automation"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"run synthesis and generate the bitstream"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Image Sensor Bringup"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"As a sanity check that the image sensor is working, let’s integrate an AXI i2c peripheral and make sure we can snag the camera sensor ID values. We will write some firmware to run on the PS (Zynq speak for the ARM cores). Here are the general steps to follow:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Make a new block design with the Zynq PS included."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Add an AXI IIC (Xilinx for I2C) block and run automation."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"create a quick block to generate an "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"xclk"}]},{"type":"text","value":" signal for the image sensor. I just divided my main clock by 4 to hit 12.5 MHz."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"I tweaked the IO pins of the I2C block to use some pins on my board that are unencumbered by pullup resistors. The ArduCam module and the Cora board that I’m using both try to be helpful by including the I2C pullup resistors, but I don’t want any pull issues so I will rely on just the ones on the camera module. "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Ensure the I2C block is seen by the Zynq. You may need to go into the Zynq block and enable it after it’s added to the block diagram. "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Generate bitstream and export hardware to SDK. "}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Firmware"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"I created a new board support package. Assuming the block design is set up correctly, the BSP will include the Xilinx IIC (I2C) driver code. Then it’s time to look at the example code provided by the I2C driver to get the basic usage pattern down. "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Examples are located in "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"TODO FILE PATH"}]},{"type":"text","value":" for me. "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"A Few Gotchas"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"It took a little while to get the sensor talking. Here were some of the things I overlooked. "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The camera sensor needs "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"xclk"}]},{"type":"text","value":" to begin replying over I2C. This became obvious after looking at the camera module pinout and wondering what "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"xclk"}]},{"type":"text","value":" was for."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The device IDs in the OV2640 datasheet are in hex! And they include the read/write bit. The read/write bit part was obvious in that two addresses were given, the radix was not obvious. It seems that Omnivision uses hex by default in their datasheets, without a "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"0x"}]},{"type":"text","value":" prefix or an "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"h"}]},{"type":"text","value":" to be seen. "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"I only uncovered this after blasting requests to all possible I2C addresses and using a logic analyzer to find the "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"ACK"}]},{"type":"text","value":". "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Note that the Xilinx I2C drivers will add a read/write bit accordingly, so only supply the 7-bit address and make sure the radix is correct. For my "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"OV2640"}]},{"type":"text","value":", this is "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"0x60"}]},{"type":"text","value":" or "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"96"}]},{"type":"text","value":". "}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Despite what the datasheet says, the OV2640 seems to have 2 options for the product ID - "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"0x42"}]},{"type":"text","value":" or "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"0x41"}]},{"type":"text","value":". I get "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"0x42"}]},{"type":"text","value":" but "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"0x41"}]},{"type":"text","value":" is in the datasheet. Given that I can read/write other registers and the "},{"type":"element","tagName":"a","properties":{"href":"https://github.com/ArduCAM/Arduino/blob/13aacea9b01540218e9ba38259f1ffa3a16383f9/ArduCAM/examples/RaspberryPi/arducam_ov2640_capture.cpp"},"children":[{"type":"text","value":"ArduCam driver"}]},{"type":"text","value":" also lists these, it’s clearly not a problem. "}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Slave addr = 60 write\n61 read"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"COM10 [4] will set the positive edge of pclk as the active edge"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"Register Set 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Register FF controls which register page is accessable. When register FF is 0x00, the addresses do this:\nReg F7 = slave ID\nMCU in the camera has BIST. "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"Register Set 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"When register FF equals 0x01\n0A = product ID number (PIDH)\n0B = product ID number (PIDL)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Set device addr = 60 write\nWrite 01 to FF \n\nRead (61) from 0x0A\nRead (61) from 0x0B"}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Designing the Camera Interface Core"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"There are several clocks in this design. "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"clk - the main system clock "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"xclk - generated by the FPGA from the main clock, fed to the image sensor"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"vclk - output from the camera, this is what the video stream is synchronized to"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Therefore, we have some clock domain crossing to handle. First, we need to transition from the vclk domain into the clk domain. This occurs when we load in a pixel from the camera (synchronized to vclk), and need to handle it within the FPGA (the exent of the ‘handling’ changes). "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"How can we handle this? Let’s look at "},{"type":"element","tagName":"a","properties":{"href":"https://zipcpu.com/blog/2017/10/20/cdc.html"},"children":[{"type":"text","value":"some examples"}]},{"type":"text","value":". "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"A few Good Links"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://embeddedprogrammer.blogspot.com/2012/07/hacking-ov7670-camera-module-sccb-cheat.html"},"children":[{"type":"text","value":"http://embeddedprogrammer.blogspot.com/2012/07/hacking-ov7670-camera-module-sccb-cheat.html"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"a","properties":{"href":"http://www.arducam.com/products/camera-breakout-board/2mp-ov2640/"},"children":[{"type":"text","value":"http://www.arducam.com/products/camera-breakout-board/2mp-ov2640/"}]}]}],"data":{"quirksMode":false}},"excerpt":"Note: this post is still a work in progress. Steps add an AXI IIC block to the design and run automation run synthesis and generate the…","timeToRead":4,"frontmatter":{"title":"Getting Started With Image Sensors Using FPGAs","userDate":"17 January 2019","date":"2019-01-17T00:00:00.000Z","tags":["Image Sensor","Camera","FPGA","Zynq","Embedded","Linux","Blog-post"],"image":{"childImageSharp":{"fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAIDBP/EABYBAQEBAAAAAAAAAAAAAAAAAAMCBP/aAAwDAQACEAMQAAABzyi2lYihT//EABsQAAMAAgMAAAAAAAAAAAAAAAACAwEEEBES/9oACAEBAAEFAsbFKDWY7Jv5GfDcf//EABcRAAMBAAAAAAAAAAAAAAAAAAABESH/2gAIAQMBAT8ByFZ//8QAFxEAAwEAAAAAAAAAAAAAAAAAAAEREv/aAAgBAgEBPwGRU2z/xAAcEAABBAMBAAAAAAAAAAAAAAABAAIQUREhgTL/2gAIAQEABj8CyQzoXlvBFiloR//EABsQAQACAgMAAAAAAAAAAAAAAAEAESFhEDFR/9oACAEBAAE/IUlSiLOzrRwv5NiKoB4TE//aAAwDAQACAAMAAAAQlD//xAAYEQACAwAAAAAAAAAAAAAAAAAAASExYf/aAAgBAwEBPxBJLSbH/8QAFhEBAQEAAAAAAAAAAAAAAAAAAEFh/9oACAECAQE/EKTR/8QAHxABAAIBAwUAAAAAAAAAAAAAAQARITFBUWFxgcHh/9oACAEBAAE/EBIFCij0mGzAv0Yp4jDVbbofIyF1BcG+d/MUNAvdn//Z","aspectRatio":1.3218770654329148,"src":"/static/9372cc92bbf5a88c049d7549f7f9443f/11c05/blinky-2.jpg","srcSet":"/static/9372cc92bbf5a88c049d7549f7f9443f/d913c/blinky-2.jpg 930w,\n/static/9372cc92bbf5a88c049d7549f7f9443f/4be77/blinky-2.jpg 1860w,\n/static/9372cc92bbf5a88c049d7549f7f9443f/11c05/blinky-2.jpg 2000w","sizes":"(max-width: 2000px) 100vw, 2000px"}}},"author":{"id":"Richard","bio":"I develop CubeSats at ORCASat by night, and embedded systems and electronics at Zaber by day. Degree in Mechatronic Systems Engineering, passionate about spacecraft, technical leadership, and STEM outreach.","avatar":{"children":[{"__typename":"ImageSharp","fixed":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAIDBAX/xAAVAQEBAAAAAAAAAAAAAAAAAAABAP/aAAwDAQACEAMQAAAB589OeKWwkKgbQn//xAAbEAACAwADAAAAAAAAAAAAAAABAgASIREiMf/aAAgBAQABBQKE9YzUFt5h1V0n3//EABURAQEAAAAAAAAAAAAAAAAAAAEQ/9oACAEDAQE/ASE//8QAFREBAQAAAAAAAAAAAAAAAAAAESD/2gAIAQIBAT8BY//EABoQAAICAwAAAAAAAAAAAAAAAAABESEQIDH/2gAIAQEABj8CFHcUrJ1//8QAGhABAAMBAQEAAAAAAAAAAAAAAQARIUExEP/aAAgBAQABPyG1c2E0Ipg9xPQFJ35HtxipKNj1P//aAAwDAQACAAMAAAAQkxCD/8QAGBEAAgMAAAAAAAAAAAAAAAAAABEBECH/2gAIAQMBAT8Q0xkK/8QAGBEAAgMAAAAAAAAAAAAAAAAAAAEQEUH/2gAIAQIBAT8Qs4WiP//EABwQAQADAAMBAQAAAAAAAAAAAAEAESExQXFhkf/aAAgBAQABPxCgAp6NYEcIGjV7i+0/kFpV61wTiYFlNYhBTUGAHzHlQFSFqER9qn//2Q==","width":400,"height":400,"src":"/static/a2b7322425489e49016cd6942dbb87ef/2e811/richard.jpg","srcSet":"/static/a2b7322425489e49016cd6942dbb87ef/2e811/richard.jpg 1x"}}]}}}},"relatedPosts":null},"pageContext":{"slug":"/2019/01/17/getting-started-fpga-image-sensor/","prev":{"excerpt":"This guidance system for drones encompasses a simulator (APM SITL) or real drone support, path planning, mission creation, drone control…","timeToRead":5,"frontmatter":{"title":"Drone Guidance System","tags":["Drone","Projects"],"date":"2019-01-03T00:00:00.000Z","image":{"childImageSharp":{"fluid":{"aspectRatio":1.3522267206477734,"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAMEBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAC/9oADAMBAAIQAxAAAAG1CCouM8P/xAAZEAABBQAAAAAAAAAAAAAAAAACAAEREyD/2gAIAQEAAQUCKUNj5//EABURAQEAAAAAAAAAAAAAAAAAAAAR/9oACAEDAQE/AYj/xAAVEQEBAAAAAAAAAAAAAAAAAAAAEf/aAAgBAgEBPwGq/8QAGRAAAQUAAAAAAAAAAAAAAAAAEQABICEi/9oACAEBAAY/AqC0Gj//xAAbEAACAgMBAAAAAAAAAAAAAAAAAREhEEFxsf/aAAgBAQABPyFPdJ3DVyiMNFn/2gAMAwEAAgADAAAAEH/v/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxAP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxAf/8QAHBAAAgICAwAAAAAAAAAAAAAAAREAITGRQWHh/9oACAEBAAE/EAADRdpGlFVXAsPFDOEXR7hOHuFCmdz/2Q==","sizes":"(max-width: 1336px) 100vw, 1336px","src":"/static/c882ea340968146366e4b203ba2dd3df/88f11/drone.jpg","srcSet":"/static/c882ea340968146366e4b203ba2dd3df/a4c3d/drone.jpg 930w,\n/static/c882ea340968146366e4b203ba2dd3df/88f11/drone.jpg 1336w"}}},"author":{"id":"Richard","bio":"I develop CubeSats at ORCASat by night, and embedded systems and electronics at Zaber by day. Degree in Mechatronic Systems Engineering, passionate about spacecraft, technical leadership, and STEM outreach.","avatar":{"children":[{"fixed":{"src":"/static/a2b7322425489e49016cd6942dbb87ef/2e811/richard.jpg"}}]}}},"fields":{"layout":"","slug":"/projects/drone-guidance-system/"}},"next":{"excerpt":"Note: this post is still a work in progress. Customizing IP RTL Now that we have an IP block that can be accessed from userspace, let’s…","timeToRead":4,"frontmatter":{"title":"Customizing AXI IP","tags":["FPGA","Zynq","Embedded","Linux","Blog-post"],"date":"2019-01-06T00:00:00.000Z","image":{"childImageSharp":{"fluid":{"aspectRatio":1.3218770654329148,"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAIDBP/EABYBAQEBAAAAAAAAAAAAAAAAAAMCBP/aAAwDAQACEAMQAAABzyi2lYihT//EABsQAAMAAgMAAAAAAAAAAAAAAAACAwEEEBES/9oACAEBAAEFAsbFKDWY7Jv5GfDcf//EABcRAAMBAAAAAAAAAAAAAAAAAAABESH/2gAIAQMBAT8ByFZ//8QAFxEAAwEAAAAAAAAAAAAAAAAAAAEREv/aAAgBAgEBPwGRU2z/xAAcEAABBAMBAAAAAAAAAAAAAAABAAIQUREhgTL/2gAIAQEABj8CyQzoXlvBFiloR//EABsQAQACAgMAAAAAAAAAAAAAAAEAESFhEDFR/9oACAEBAAE/IUlSiLOzrRwv5NiKoB4TE//aAAwDAQACAAMAAAAQlD//xAAYEQACAwAAAAAAAAAAAAAAAAAAASExYf/aAAgBAwEBPxBJLSbH/8QAFhEBAQEAAAAAAAAAAAAAAAAAAEFh/9oACAECAQE/EKTR/8QAHxABAAIBAwUAAAAAAAAAAAAAAQARITFBUWFxgcHh/9oACAEBAAE/EBIFCij0mGzAv0Yp4jDVbbofIyF1BcG+d/MUNAvdn//Z","sizes":"(max-width: 2000px) 100vw, 2000px","src":"/static/9372cc92bbf5a88c049d7549f7f9443f/11c05/blinky-2.jpg","srcSet":"/static/9372cc92bbf5a88c049d7549f7f9443f/d913c/blinky-2.jpg 930w,\n/static/9372cc92bbf5a88c049d7549f7f9443f/4be77/blinky-2.jpg 1860w,\n/static/9372cc92bbf5a88c049d7549f7f9443f/11c05/blinky-2.jpg 2000w"}}},"author":{"id":"Richard","bio":"I develop CubeSats at ORCASat by night, and embedded systems and electronics at Zaber by day. Degree in Mechatronic Systems Engineering, passionate about spacecraft, technical leadership, and STEM outreach.","avatar":{"children":[{"fixed":{"src":"/static/a2b7322425489e49016cd6942dbb87ef/2e811/richard.jpg"}}]}}},"fields":{"layout":"","slug":"/2019/01/06/cora-customizing-axi-ip/"}},"primaryTag":"Image Sensor"}}