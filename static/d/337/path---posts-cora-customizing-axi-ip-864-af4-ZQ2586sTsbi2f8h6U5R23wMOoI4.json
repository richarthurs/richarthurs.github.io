{"data":{"logo":{"childImageSharp":{"fixed":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAAC4jAAAuIwF4pT92AAAAf0lEQVQI12P49++f3v///xWBmBuIOYBYigEJQMXEobQ0kpg8EDMxoAOg4HQgzgbiBCB2AeJaIHYE4jAgjgbiFCD2BWI3IG6FymUCcQWUtoWqCwKpARkYBcReQJwF1egBZdcAXQ/ix0MtAmlMB4r5AGkHIA4BskGW5kMdZALESQDh3apPUyViLgAAAABJRU5ErkJggg==","width":400,"height":64,"src":"/static/1642a962a17c5982edb23d2f20e5a8e6/51380/logo.png","srcSet":"/static/1642a962a17c5982edb23d2f20e5a8e6/51380/logo.png 1x,\n/static/1642a962a17c5982edb23d2f20e5a8e6/240c8/logo.png 1.5x,\n/static/1642a962a17c5982edb23d2f20e5a8e6/f5cf3/logo.png 2x,\n/static/1642a962a17c5982edb23d2f20e5a8e6/01d7c/logo.png 3x"}}},"markdownRemark":{"html":"<h3>Customizing IP RTL</h3>\n<p>Now that we have an IP block that can be accessed from userspace, let’s customize it with a register that the user can read to determine the state of the LEDs. Right now, the example only has a writable register. These changes will allow the user to read data from the block using a memory-mapped register. </p>\n<p>To do this, we will edit the IP block and assign some of the counter bits to an axi-accessable register. </p>\n<ul>\n<li>\n<p>Right click on the block and choose <code class=\"language-text\">edit in IP packager</code>. This opens up a new temporary Vivado project that allows you to change the RTL, save the changes, and have them reflected in the main project that uses the IP block.\n<img src=\"../img/cora-bringup2/2-edit-ip.png\" alt=\"Edit IP\">\n<em>Above: Edit the IP</em></p>\n</li>\n<li>\n<p>Add the lines to assign the counter to a user-accessible register</p>\n</li>\n</ul>\n<p>// TODO: insert code</p>\n<ul>\n<li>Save and close the Vivado window</li>\n<li>Vivado will alert you that something is out of date and needs to be updated, choose <code class=\"language-text\">Refresh IP status</code> and then <code class=\"language-text\">Update Selected</code>.</li>\n</ul>\n<p><img src=\"../img/cora-bringup2/2-upgrade-selected.png\" alt=\"Edit IP\">\n<em>Above: Upgrade the selected IP</em></p>\n<ul>\n<li>\n<p>Vivado will alert you to generate the output products again\n<img src=\"../img/cora-bringup2/2-generate-output.png\" alt=\"Generate output products\">\n<em>Above: Generate the output products</em></p>\n</li>\n<li>\n<p>Or, run synthesis and implementation again and generate bitstream if you hit cancel before. </p>\n</li>\n</ul>\n<h3>Customizing Application Software</h3>\n<p>Now that the RTL is coded and the bitstream has been generated, it’s time to head back into SDK and update the application software so that we can use the new hardware capabilities. </p>\n<p>// talk about the updates to the application</p>\n<p>// talk about updates to the kernel driver</p>\n<ul>\n<li>I updated the kernel driver with the new read command </li>\n<li>Rebuild the petalinux image with <code class=\"language-text\">petalinux-build</code>. Unlike the first time around, the build this time only takes around 4 minutes since the changes are minor. </li>\n<li>Move the petalinux files over to the SD card. </li>\n<li>Initialize the kernel module as per the tutorial. I later moved these commands into a shell script and I placed it on the <code class=\"language-text\">bulk</code> partition of my SD card so it sticks around between resets.</li>\n<li>Upon running the app for the first time, nothing crashed. However, I was not seeing the results I expected (this turned out to be an RTL bug, which I found later). </li>\n</ul>\n<p>Since things weren’t working at this point, I tried several things during the debug process, which are worth mentioning. </p>\n<ul>\n<li>\n<p>I used the <code class=\"language-text\">devmem</code> command to look at the memory directly, instead of interacting through the application. </p>\n<p><code class=\"language-text\">devmem 0x43C00000</code> returns the value of the user-writable bit that starts and stops the blinking, since it is mapped to user register 0 in the HDL. </p>\n<p>When the RTL bug was fixed, <code class=\"language-text\">devmem 0x43C00008</code> returns the counter value. </p>\n</li>\n<li>\n<p>One of the issues was I neglected to export the new hardware from Vivado to SDK, so I was flashing the FPGA with old code that didn’t update an AXI-accessable register with the counter value. </p>\n</li>\n</ul>\n<p>I also ended up adapting the c file <a href=\"http://svenand.blogdrives.com/files/gpio-dev-mem-test.c\">here</a>, which I found from <a href=\"http://fpga.org/2013/05/28/how-to-design-and-access-a-memory-mapped-device-part-two/\">this tutorial</a>. I wrote this on the board over an SSH connection and compiled it with <code class=\"language-text\">gcc filename.c</code>. As before, I did this on the partition of my SD card which I mounted to a directory (<code class=\"language-text\">sdcard</code>) with the command: <code class=\"language-text\">mount /dev/mmcblk0p2 ./sdcard</code>. </p>\n<p>Here is the final test C file. I played around with this and ended up solving the RTL issue. This exposed the fact that my Linux device driver was not correct, since it was not able to read the register, but the test file could. </p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;sys/mman.h&gt;\n#include &lt;fcntl.h&gt;\n\nint main(void){\nunsigned addr, offset;\n\nint reg_addr = 0x43c00000;\n\nint value;\nint fd;\n\nvoid *ptr;\nunsigned pg_sz = sysconf(_SC_PAGESIZE);\n\nprintf(&quot;Access through /dev/mem - pg_sz: %x\\n&quot;, pg_sz);\n\n// Open the mem file\nfd = open(&quot;/dev/mem&quot;, O_RDWR);\nif(fd &lt; 1){\n        perror(&quot;can&#39;t open&quot;);\n        return -1;\n}\n\n// mmap the device into memory\naddr = (reg_addr &amp; (~(pg_sz - 1)));\noffset = (reg_addr - addr);\nptr = mmap(NULL, pg_sz, PROT_READ|PROT_WRITE, MAP_SHARED, fd, addr);\n\n// Read values from device registers:\nfor(int i = 0; i &lt; 4; i +=1){\n        value = *((unsigned *)(ptr + offset + i*4));\n        printf(&quot;Value from reg%d: %x\\n&quot;,i, value);\n}\n\n// Write to a reg and read it back\n*((unsigned *)(ptr + offset + 12)) = 0xdeadbeef;\nvalue = *((unsigned *) (ptr + offset + 12));\nprintf(&quot;Reg3 after write: %x\\n&quot;, value);\n\nreturn 0;\n}</code></pre></div>","htmlAst":{"type":"root","children":[{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Customizing IP RTL"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Now that we have an IP block that can be accessed from userspace, let’s customize it with a register that the user can read to determine the state of the LEDs. Right now, the example only has a writable register. These changes will allow the user to read data from the block using a memory-mapped register. "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"To do this, we will edit the IP block and assign some of the counter bits to an axi-accessable register. "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Right click on the block and choose "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"edit in IP packager"}]},{"type":"text","value":". This opens up a new temporary Vivado project that allows you to change the RTL, save the changes, and have them reflected in the main project that uses the IP block.\n"},{"type":"element","tagName":"img","properties":{"src":"../img/cora-bringup2/2-edit-ip.png","alt":"Edit IP"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"Above: Edit the IP"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Add the lines to assign the counter to a user-accessible register"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"// TODO: insert code"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Save and close the Vivado window"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Vivado will alert you that something is out of date and needs to be updated, choose "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Refresh IP status"}]},{"type":"text","value":" and then "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Update Selected"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"../img/cora-bringup2/2-upgrade-selected.png","alt":"Edit IP"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"Above: Upgrade the selected IP"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Vivado will alert you to generate the output products again\n"},{"type":"element","tagName":"img","properties":{"src":"../img/cora-bringup2/2-generate-output.png","alt":"Generate output products"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"Above: Generate the output products"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Or, run synthesis and implementation again and generate bitstream if you hit cancel before. "}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Customizing Application Software"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Now that the RTL is coded and the bitstream has been generated, it’s time to head back into SDK and update the application software so that we can use the new hardware capabilities. "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"// talk about the updates to the application"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"// talk about updates to the kernel driver"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"I updated the kernel driver with the new read command "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Rebuild the petalinux image with "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"petalinux-build"}]},{"type":"text","value":". Unlike the first time around, the build this time only takes around 4 minutes since the changes are minor. "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Move the petalinux files over to the SD card. "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Initialize the kernel module as per the tutorial. I later moved these commands into a shell script and I placed it on the "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"bulk"}]},{"type":"text","value":" partition of my SD card so it sticks around between resets."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Upon running the app for the first time, nothing crashed. However, I was not seeing the results I expected (this turned out to be an RTL bug, which I found later). "}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Since things weren’t working at this point, I tried several things during the debug process, which are worth mentioning. "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"I used the "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"devmem"}]},{"type":"text","value":" command to look at the memory directly, instead of interacting through the application. "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"devmem 0x43C00000"}]},{"type":"text","value":" returns the value of the user-writable bit that starts and stops the blinking, since it is mapped to user register 0 in the HDL. "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"When the RTL bug was fixed, "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"devmem 0x43C00008"}]},{"type":"text","value":" returns the counter value. "}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"One of the issues was I neglected to export the new hardware from Vivado to SDK, so I was flashing the FPGA with old code that didn’t update an AXI-accessable register with the counter value. "}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"I also ended up adapting the c file "},{"type":"element","tagName":"a","properties":{"href":"http://svenand.blogdrives.com/files/gpio-dev-mem-test.c"},"children":[{"type":"text","value":"here"}]},{"type":"text","value":", which I found from "},{"type":"element","tagName":"a","properties":{"href":"http://fpga.org/2013/05/28/how-to-design-and-access-a-memory-mapped-device-part-two/"},"children":[{"type":"text","value":"this tutorial"}]},{"type":"text","value":". I wrote this on the board over an SSH connection and compiled it with "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"gcc filename.c"}]},{"type":"text","value":". As before, I did this on the partition of my SD card which I mounted to a directory ("},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"sdcard"}]},{"type":"text","value":") with the command: "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"mount /dev/mmcblk0p2 ./sdcard"}]},{"type":"text","value":". "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Here is the final test C file. I played around with this and ended up solving the RTL issue. This exposed the fact that my Linux device driver was not correct, since it was not able to read the register, but the test file could. "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"c"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-c"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-c"]},"children":[{"type":"text","value":"#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n\nint main(void){\nunsigned addr, offset;\n\nint reg_addr = 0x43c00000;\n\nint value;\nint fd;\n\nvoid *ptr;\nunsigned pg_sz = sysconf(_SC_PAGESIZE);\n\nprintf(\"Access through /dev/mem - pg_sz: %x\\n\", pg_sz);\n\n// Open the mem file\nfd = open(\"/dev/mem\", O_RDWR);\nif(fd < 1){\n        perror(\"can't open\");\n        return -1;\n}\n\n// mmap the device into memory\naddr = (reg_addr & (~(pg_sz - 1)));\noffset = (reg_addr - addr);\nptr = mmap(NULL, pg_sz, PROT_READ|PROT_WRITE, MAP_SHARED, fd, addr);\n\n// Read values from device registers:\nfor(int i = 0; i < 4; i +=1){\n        value = *((unsigned *)(ptr + offset + i*4));\n        printf(\"Value from reg%d: %x\\n\",i, value);\n}\n\n// Write to a reg and read it back\n*((unsigned *)(ptr + offset + 12)) = 0xdeadbeef;\nvalue = *((unsigned *) (ptr + offset + 12));\nprintf(\"Reg3 after write: %x\\n\", value);\n\nreturn 0;\n}"}]}]}]}],"data":{"quirksMode":false}},"excerpt":"Customizing IP RTL Now that we have an IP block that can be accessed from userspace, let’s customize it with a register that the user can…","timeToRead":3,"frontmatter":{"title":"","userDate":null,"date":null,"tags":null,"image":null,"author":null}},"relatedPosts":null},"pageContext":{"slug":"/posts/cora-customizing-axi-ip/","prev":{"excerpt":"This post contains notes that I generated while bringing up Petalinux on my Cora Z7-10 Zynq board. First I get Petalinux working and do a…","timeToRead":11,"frontmatter":{"title":"Petalinux Bringup on Cora Z7-10 Zynq Board","tags":["FPGA","Zynq","Embedded","Linux","Blog-post"],"date":"2019-01-05T00:00:00.000Z","image":{"childImageSharp":{"fluid":{"aspectRatio":1.3218770654329148,"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAIDBP/EABYBAQEBAAAAAAAAAAAAAAAAAAMCBP/aAAwDAQACEAMQAAABzyi2lYihT//EABsQAAMAAgMAAAAAAAAAAAAAAAACAwEEEBES/9oACAEBAAEFAsbFKDWY7Jv5GfDcf//EABcRAAMBAAAAAAAAAAAAAAAAAAABESH/2gAIAQMBAT8ByFZ//8QAFxEAAwEAAAAAAAAAAAAAAAAAAAEREv/aAAgBAgEBPwGRU2z/xAAcEAABBAMBAAAAAAAAAAAAAAABAAIQUREhgTL/2gAIAQEABj8CyQzoXlvBFiloR//EABsQAQACAgMAAAAAAAAAAAAAAAEAESFhEDFR/9oACAEBAAE/IUlSiLOzrRwv5NiKoB4TE//aAAwDAQACAAMAAAAQlD//xAAYEQACAwAAAAAAAAAAAAAAAAAAASExYf/aAAgBAwEBPxBJLSbH/8QAFhEBAQEAAAAAAAAAAAAAAAAAAEFh/9oACAECAQE/EKTR/8QAHxABAAIBAwUAAAAAAAAAAAAAAQARITFBUWFxgcHh/9oACAEBAAE/EBIFCij0mGzAv0Yp4jDVbbofIyF1BcG+d/MUNAvdn//Z","sizes":"(max-width: 2000px) 100vw, 2000px","src":"/static/9372cc92bbf5a88c049d7549f7f9443f/11c05/blinky-2.jpg","srcSet":"/static/9372cc92bbf5a88c049d7549f7f9443f/d913c/blinky-2.jpg 930w,\n/static/9372cc92bbf5a88c049d7549f7f9443f/4be77/blinky-2.jpg 1860w,\n/static/9372cc92bbf5a88c049d7549f7f9443f/11c05/blinky-2.jpg 2000w"}}},"author":{"id":"Richard","bio":"Mechatronics Systems engineering student passionate about space, interested in high-reliability embedded systems and computer vision. Currently turning coffee into CubeSats and drones.","avatar":{"children":[{"fixed":{"src":"/static/a2b7322425489e49016cd6942dbb87ef/2e811/richard.jpg"}}]}}},"fields":{"layout":"","slug":"/posts/cora-linux-getting-started/"}},"next":{"excerpt":"The TI Tiva Launchpad boards are an excellent way to get started working with ARM microcontrollers. With the Tivaware software suite, they…","timeToRead":6,"frontmatter":{"title":"TI ARM LaunchPad GPIO Input Tutorial","tags":["microcontroller","TI","ARM","tutorial","Blog-post"],"date":"2015-05-25T00:00:00.000Z","image":{"childImageSharp":{"fluid":{"aspectRatio":1.3333333333333333,"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAwACBf/EABUBAQEAAAAAAAAAAAAAAAAAAAME/9oADAMBAAIQAxAAAAHmKhVqNiIf/8QAGRAAAwEBAQAAAAAAAAAAAAAAAAECEQMS/9oACAEBAAEFAp5ukoNFqn0kOj//xAAWEQEBAQAAAAAAAAAAAAAAAAACEEH/2gAIAQMBAT8BIOz/xAAYEQACAwAAAAAAAAAAAAAAAAACAxARMf/aAAgBAgEBPwFp3kf/xAAaEAACAgMAAAAAAAAAAAAAAAABEABBAhEh/9oACAEBAAY/At1OFHKn/8QAGBABAQEBAQAAAAAAAAAAAAAAAREAITH/2gAIAQEAAT8hjchnXVGFDMsQ1BmrFmRfN//aAAwDAQACAAMAAAAQdx//xAAYEQEBAAMAAAAAAAAAAAAAAAABABEhwf/aAAgBAwEBPxARh8kB03//xAAXEQEBAQEAAAAAAAAAAAAAAAABACFB/9oACAECAQE/EBNzpf/EABsQAQEAAwADAAAAAAAAAAAAAAERACExUXHB/9oACAEBAAE/EGMFBC313DC7mdV+YrJJ57hMGYE7HBfCt0buFoACAHM//9k=","sizes":"(max-width: 3264px) 100vw, 3264px","src":"/static/1a3dc0006a5adae718d145990e724821/b326b/tiva-launchpad-header.jpg","srcSet":"/static/1a3dc0006a5adae718d145990e724821/4018e/tiva-launchpad-header.jpg 930w,\n/static/1a3dc0006a5adae718d145990e724821/88222/tiva-launchpad-header.jpg 1860w,\n/static/1a3dc0006a5adae718d145990e724821/b326b/tiva-launchpad-header.jpg 3264w"}}},"author":{"id":"Richard","bio":"Mechatronics Systems engineering student passionate about space, interested in high-reliability embedded systems and computer vision. Currently turning coffee into CubeSats and drones.","avatar":{"children":[{"fixed":{"src":"/static/a2b7322425489e49016cd6942dbb87ef/2e811/richard.jpg"}}]}}},"fields":{"layout":"","slug":"/posts/ti-launchpad-gpio-input/"}},"primaryTag":""}}