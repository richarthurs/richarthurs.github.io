{"data":{"logo":{"childImageSharp":{"fixed":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAAC4jAAAuIwF4pT92AAAAf0lEQVQI12P49++f3v///xWBmBuIOYBYigEJQMXEobQ0kpg8EDMxoAOg4HQgzgbiBCB2AeJaIHYE4jAgjgbiFCD2BWI3IG6FymUCcQWUtoWqCwKpARkYBcReQJwF1egBZdcAXQ/ix0MtAmlMB4r5AGkHIA4BskGW5kMdZALESQDh3apPUyViLgAAAABJRU5ErkJggg==","width":400,"height":64,"src":"/static/1642a962a17c5982edb23d2f20e5a8e6/51380/logo.png","srcSet":"/static/1642a962a17c5982edb23d2f20e5a8e6/51380/logo.png 1x,\n/static/1642a962a17c5982edb23d2f20e5a8e6/240c8/logo.png 1.5x,\n/static/1642a962a17c5982edb23d2f20e5a8e6/f5cf3/logo.png 2x,\n/static/1642a962a17c5982edb23d2f20e5a8e6/01d7c/logo.png 3x"}}},"markdownRemark":{"html":"<p>The TI Tiva Launchpad boards are an excellent way to get started working with ARM microcontrollers. With the Tivaware software suite, they’re not too much harder than an Arduino to program, either. I’ve found the tutorials from TI and elsewhere online to be very helpful. Unfortunately, the TI tutorials go over GPIO outputs, which are pretty simple, but they totally skip inputs! For someone totally unsure where to look for the correct documentation, I feel this is a major oversight. Fortunately, I’ve been able to figure it out with the help of some 3rd party tutorials. Here’s my take on how to use GPIO inputs, with references back to the TI material so you can get an idea of where to look for functionality in the main documentation.</p>\n<p>I’ll explain the setup and put the code at the end of this post, along with some links.</p>\n<h2>Setup</h2>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">#include &lt;stdint.h&gt;\n#include &lt;stdbool.h&gt;\n#include &quot;inc/hw_types.h&quot;\n#include &quot;inc/hw_memmap.h&quot;\n#include &quot;driverlib/sysctl.h&quot;\n#include &quot;driverlib/gpio.h&quot;\nint main(void)\n{\n  SysCtlClockSet(SYSCTL_SYSDIV_4|SYSCTL_USE_PLL|SYSCTL_XTAL_16MHZ|SYSCTL_OSC_MAIN);\t// set up the clock\n  SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);\t// enable port F\n  GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3);\t// enable outputs on the launchpad LED pins</code></pre></div>\n<p>As usual, we need to include the appropriate headers for the board and set up the clock. We also need to enable port F. Then, we set up GPIO F1, F2 and F3 as outputs. This is where the LaunchPad’s red, green and blue LEDs are connected. Also note that some pins need to be unlocked with a code from the datasheet before you can use them. That’s because they’re normally used for one of the programming interfaces. There are examples of this in the Tiva tutorials from TI. Take a look at my tutorial on how to unlock GPIOs.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">GPIOPinTypeGPIOInput(GPIO_PORTF_BASE, GPIO_PIN_4);\t// make F4 an input\n\nGPIOPadConfigSet(GPIO_PORTF_BASE,GPIO_PIN_4,GPIO_STRENGTH_2MA,GPIO_PIN_TYPE_STD_WPU);\t// enable F4&#39;s pullup, the drive strength won&#39;t affect the input</code></pre></div>\n<p>Here’s where we start getting to the input side of things. We need to enable port F4 as an input. Pretty simple, but it doesn’t end there. To make it work correctly, we’ll configure the pin to have an internal pullup resistor. WPU stands for ‘weak pullup resistor’ - you could change this to WPD for a pulldown. The details of this function can be found on page 264 here.</p>\n<p>By giving the pin an internal pullup, we know that when the button is pressed, the input will be grounded (from the LaunchPad datasheet). Otherwise, it’ll be pulled up to 3.3v. That’s the key to making inputs work, but let’s peek at the rest of the code.</p>\n<h3>Loop</h3>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">while(1)\n  {\n    uint32_t pinVal=0;\t// variable to hold the pinRead\n    pinVal= GPIOPinRead(GPIO_PORTF_BASE,GPIO_PIN_4);\t// read F4</code></pre></div>\n<p>Pretty standard microcontroller stuff, we’ve got a while(1) loop. This will run forever. Next, we create a 32-bit integer to take the value of GPIOPinRead. This function returns a 32 bit value, but we only need bits 1-8, which will be set if any of the pins on the port are high. GPIOPinRead takes the base port and the specific pin as arguments.</p>\n<h3>If</h3>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">if( (pinVal &amp; GPIO_PIN_4)==0){\t// AND to strip out anything but the value read from F4\n      GPIOPinWrite(GPIO_PORTF_BASE,GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3, 2);\t// turn on one LED\n    }\n    \n    else{\n      GPIOPinWrite(GPIO_PORTF_BASE,GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3, 4);\t// turn on a different LED\n    }</code></pre></div>\n<p>Next we have an if statement. It’s pretty easy to see what’s being done here. If the pin is high, we turn on GPIO F2 (that’s the else condition). Otherwise, our input is low (button pressed) and we’ll turn on pin F1.</p>\n<p>There’s a little bit going on in the if statement though. We’re taking the value from GPIOPinRead, which will have a 0 or a 1 in the position of any pins we read. We logical AND it with the GPIO<em>PIN</em>4 variable, which will strip away anything except the value in Pin 4’s position. If pin 4 was high, we will get a result of 1. If pin 4 was low, we get a 0. This is because we AND the value on the input, in the input’s place, with a 1 in the input’s place.</p>\n<h4>What’s the delay for?</h4>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">//   SysCtlDelay(7000000); // uncomment me if you need debouncing\n\n  }\n}</code></pre></div>\n<p>There is an optional delay at the bottom of the code. This is for very simple debouncing of the button. Essentially, when you push a button, it doesn’t immediately connect one way or the other. It’ll actually bounce around between connected and disconnected. This is a physical phenomenon due to springiness. It’s very fast, but not too fast for a micro to keep up with. In some applications, like if you were making each button press increment a counter, you would likely see more than one increment of the counter for each button press, due to the button bouncing a little bit. If you’re just using a button to turn on an LED with no latching, button bounce isn’t something to worry about.</p>\n<h3>Button bounce</h3>\n<p>By waiting around for a few ms after reading the button, we physically give it time to settle into wherever it wants to be. Debouncing could be a whole series of blog posts, as you can deal with it in multiple ways through hardware or software. If you find you need it, busy wait delays are the most simple way to deal with it, though they’re definitely not the best.</p>\n<p><img src=\"/button-bounce-4a8d824615e0d25da0fe525be2899741.gif\" alt=\"bounce waveform\">\n<em>Button bounce waveform</em></p>\n<h3>Complete code</h3>\n<p>Here’s the complete code for this tutorial. It’s all commented and should be easy to figure out. The project containing this code was actually the Lab 2 code from TI’s set of tutorials. The includes and build options are the same, you just need to put in a few lines to enable and work with the inputs.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">/* \nTivaware input tutorial\n*/\n\n#include &lt;stdint.h&gt;\n#include &lt;stdbool.h&gt;\n#include &quot;inc/hw_types.h&quot;\n#include &quot;inc/hw_memmap.h&quot;\n#include &quot;driverlib/sysctl.h&quot;\n#include &quot;driverlib/gpio.h&quot;\nint main(void)\n{\n  SysCtlClockSet(SYSCTL_SYSDIV_4|SYSCTL_USE_PLL|SYSCTL_XTAL_16MHZ|SYSCTL_OSC_MAIN);\t// set up the clock\n  SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);\t// enable port F\n  GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3);\t// enable outputs on the launchpad LED pins\n  GPIOPinTypeGPIOInput(GPIO_PORTF_BASE, GPIO_PIN_4);\t// make F4 an input\n\n  GPIOPadConfigSet(GPIO_PORTF_BASE,GPIO_PIN_4,GPIO_STRENGTH_2MA,GPIO_PIN_TYPE_STD_WPU);\t// enable F4&#39;s pullup, the drive strength won&#39;t affect the input\n  while(1)\n  {\n    uint32_t pinVal=0;\t// variable to hold the pinRead\n    pinVal= GPIOPinRead(GPIO_PORTF_BASE,GPIO_PIN_4);\t// read F4\n    \n    if( (pinVal &amp; GPIO_PIN_4)==0){\t// AND to strip out anything but the value read from F4\n      GPIOPinWrite(GPIO_PORTF_BASE,GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3, 2);\t// turn on one LED\n    }\n    \n    else{\n      GPIOPinWrite(GPIO_PORTF_BASE,GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3, 4);\t// turn on a different LED\n    }\n        \n    //   SysCtlDelay(7000000); // uncomment me if you need debouncing\n\n  }\n}</code></pre></div>\n<h3>Resources</h3>\n<p>I’ll end off with some resources for learning about the ARM LaunchPad. There will definitely be more tutorials from me as well!</p>\n<p><a href=\"http://processors.wiki.ti.com/index.php/Tiva_C_Series_TM4C123G_LaunchPad\">TI LaunchPad resources</a></p>\n<p><a href=\"http://www.ti.com/lit/ug/spmu298a/spmu298a.pdf\">Tivaware Reference</a></p>\n<p><a href=\"%22http://processors.wiki.ti.com/index.php?title=Getting_Started_with_the_TIVA%E2%84%A2_C_Series_TM4C123G_LaunchPad&#x26;DCMP=tivac&#x26;HQS=TM4C123G-Launchpad-Workshop\">TI LaunchPad Workshop</a></p>\n<p><a href=\"https://www.youtube.com/watch?v=qieNBhmWQbA\">AllaboutEE Input Tutorial (C++)</a></p>\n<p><a href=\"https://sites.google.com/site/luiselectronicprojects/tutorials/tiva-tutorials/tiva-gpio/simple-digital-input\">Luis Electronic Projects Input Tutorial</a></p>","htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The TI Tiva Launchpad boards are an excellent way to get started working with ARM microcontrollers. With the Tivaware software suite, they’re not too much harder than an Arduino to program, either. I’ve found the tutorials from TI and elsewhere online to be very helpful. Unfortunately, the TI tutorials go over GPIO outputs, which are pretty simple, but they totally skip inputs! For someone totally unsure where to look for the correct documentation, I feel this is a major oversight. Fortunately, I’ve been able to figure it out with the help of some 3rd party tutorials. Here’s my take on how to use GPIO inputs, with references back to the TI material so you can get an idea of where to look for functionality in the main documentation."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"I’ll explain the setup and put the code at the end of this post, along with some links."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Setup"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"c"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-c"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-c"]},"children":[{"type":"text","value":"#include <stdint.h>\n#include <stdbool.h>\n#include \"inc/hw_types.h\"\n#include \"inc/hw_memmap.h\"\n#include \"driverlib/sysctl.h\"\n#include \"driverlib/gpio.h\"\nint main(void)\n{\n  SysCtlClockSet(SYSCTL_SYSDIV_4|SYSCTL_USE_PLL|SYSCTL_XTAL_16MHZ|SYSCTL_OSC_MAIN);\t// set up the clock\n  SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);\t// enable port F\n  GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3);\t// enable outputs on the launchpad LED pins"}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"As usual, we need to include the appropriate headers for the board and set up the clock. We also need to enable port F. Then, we set up GPIO F1, F2 and F3 as outputs. This is where the LaunchPad’s red, green and blue LEDs are connected. Also note that some pins need to be unlocked with a code from the datasheet before you can use them. That’s because they’re normally used for one of the programming interfaces. There are examples of this in the Tiva tutorials from TI. Take a look at my tutorial on how to unlock GPIOs."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"c"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-c"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-c"]},"children":[{"type":"text","value":"GPIOPinTypeGPIOInput(GPIO_PORTF_BASE, GPIO_PIN_4);\t// make F4 an input\n\nGPIOPadConfigSet(GPIO_PORTF_BASE,GPIO_PIN_4,GPIO_STRENGTH_2MA,GPIO_PIN_TYPE_STD_WPU);\t// enable F4's pullup, the drive strength won't affect the input"}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Here’s where we start getting to the input side of things. We need to enable port F4 as an input. Pretty simple, but it doesn’t end there. To make it work correctly, we’ll configure the pin to have an internal pullup resistor. WPU stands for ‘weak pullup resistor’ - you could change this to WPD for a pulldown. The details of this function can be found on page 264 here."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"By giving the pin an internal pullup, we know that when the button is pressed, the input will be grounded (from the LaunchPad datasheet). Otherwise, it’ll be pulled up to 3.3v. That’s the key to making inputs work, but let’s peek at the rest of the code."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Loop"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"c"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-c"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-c"]},"children":[{"type":"text","value":"while(1)\n  {\n    uint32_t pinVal=0;\t// variable to hold the pinRead\n    pinVal= GPIOPinRead(GPIO_PORTF_BASE,GPIO_PIN_4);\t// read F4"}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Pretty standard microcontroller stuff, we’ve got a while(1) loop. This will run forever. Next, we create a 32-bit integer to take the value of GPIOPinRead. This function returns a 32 bit value, but we only need bits 1-8, which will be set if any of the pins on the port are high. GPIOPinRead takes the base port and the specific pin as arguments."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"If"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"c"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-c"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-c"]},"children":[{"type":"text","value":"if( (pinVal & GPIO_PIN_4)==0){\t// AND to strip out anything but the value read from F4\n      GPIOPinWrite(GPIO_PORTF_BASE,GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3, 2);\t// turn on one LED\n    }\n    \n    else{\n      GPIOPinWrite(GPIO_PORTF_BASE,GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3, 4);\t// turn on a different LED\n    }"}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Next we have an if statement. It’s pretty easy to see what’s being done here. If the pin is high, we turn on GPIO F2 (that’s the else condition). Otherwise, our input is low (button pressed) and we’ll turn on pin F1."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"There’s a little bit going on in the if statement though. We’re taking the value from GPIOPinRead, which will have a 0 or a 1 in the position of any pins we read. We logical AND it with the GPIO"},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"PIN"}]},{"type":"text","value":"4 variable, which will strip away anything except the value in Pin 4’s position. If pin 4 was high, we will get a result of 1. If pin 4 was low, we get a 0. This is because we AND the value on the input, in the input’s place, with a 1 in the input’s place."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"What’s the delay for?"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"c"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-c"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-c"]},"children":[{"type":"text","value":"//   SysCtlDelay(7000000); // uncomment me if you need debouncing\n\n  }\n}"}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"There is an optional delay at the bottom of the code. This is for very simple debouncing of the button. Essentially, when you push a button, it doesn’t immediately connect one way or the other. It’ll actually bounce around between connected and disconnected. This is a physical phenomenon due to springiness. It’s very fast, but not too fast for a micro to keep up with. In some applications, like if you were making each button press increment a counter, you would likely see more than one increment of the counter for each button press, due to the button bouncing a little bit. If you’re just using a button to turn on an LED with no latching, button bounce isn’t something to worry about."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Button bounce"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"By waiting around for a few ms after reading the button, we physically give it time to settle into wherever it wants to be. Debouncing could be a whole series of blog posts, as you can deal with it in multiple ways through hardware or software. If you find you need it, busy wait delays are the most simple way to deal with it, though they’re definitely not the best."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"/button-bounce-4a8d824615e0d25da0fe525be2899741.gif","alt":"bounce waveform"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"Button bounce waveform"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Complete code"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Here’s the complete code for this tutorial. It’s all commented and should be easy to figure out. The project containing this code was actually the Lab 2 code from TI’s set of tutorials. The includes and build options are the same, you just need to put in a few lines to enable and work with the inputs."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"c"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-c"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-c"]},"children":[{"type":"text","value":"/* \nTivaware input tutorial\n*/\n\n#include <stdint.h>\n#include <stdbool.h>\n#include \"inc/hw_types.h\"\n#include \"inc/hw_memmap.h\"\n#include \"driverlib/sysctl.h\"\n#include \"driverlib/gpio.h\"\nint main(void)\n{\n  SysCtlClockSet(SYSCTL_SYSDIV_4|SYSCTL_USE_PLL|SYSCTL_XTAL_16MHZ|SYSCTL_OSC_MAIN);\t// set up the clock\n  SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);\t// enable port F\n  GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3);\t// enable outputs on the launchpad LED pins\n  GPIOPinTypeGPIOInput(GPIO_PORTF_BASE, GPIO_PIN_4);\t// make F4 an input\n\n  GPIOPadConfigSet(GPIO_PORTF_BASE,GPIO_PIN_4,GPIO_STRENGTH_2MA,GPIO_PIN_TYPE_STD_WPU);\t// enable F4's pullup, the drive strength won't affect the input\n  while(1)\n  {\n    uint32_t pinVal=0;\t// variable to hold the pinRead\n    pinVal= GPIOPinRead(GPIO_PORTF_BASE,GPIO_PIN_4);\t// read F4\n    \n    if( (pinVal & GPIO_PIN_4)==0){\t// AND to strip out anything but the value read from F4\n      GPIOPinWrite(GPIO_PORTF_BASE,GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3, 2);\t// turn on one LED\n    }\n    \n    else{\n      GPIOPinWrite(GPIO_PORTF_BASE,GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3, 4);\t// turn on a different LED\n    }\n        \n    //   SysCtlDelay(7000000); // uncomment me if you need debouncing\n\n  }\n}"}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Resources"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"I’ll end off with some resources for learning about the ARM LaunchPad. There will definitely be more tutorials from me as well!"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://processors.wiki.ti.com/index.php/Tiva_C_Series_TM4C123G_LaunchPad"},"children":[{"type":"text","value":"TI LaunchPad resources"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://www.ti.com/lit/ug/spmu298a/spmu298a.pdf"},"children":[{"type":"text","value":"Tivaware Reference"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"%22http://processors.wiki.ti.com/index.php?title=Getting_Started_with_the_TIVA%E2%84%A2_C_Series_TM4C123G_LaunchPad&DCMP=tivac&HQS=TM4C123G-Launchpad-Workshop"},"children":[{"type":"text","value":"TI LaunchPad Workshop"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://www.youtube.com/watch?v=qieNBhmWQbA"},"children":[{"type":"text","value":"AllaboutEE Input Tutorial (C++)"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://sites.google.com/site/luiselectronicprojects/tutorials/tiva-tutorials/tiva-gpio/simple-digital-input"},"children":[{"type":"text","value":"Luis Electronic Projects Input Tutorial"}]}]}],"data":{"quirksMode":false}},"excerpt":"The TI Tiva Launchpad boards are an excellent way to get started working with ARM microcontrollers. With the Tivaware software suite, they…","timeToRead":6,"frontmatter":{"title":"TI ARM LaunchPad GPIO Input Tutorial","userDate":"25 May 2015","date":"2015-05-25T00:00:00.000Z","tags":["microcontroller","TI","ARM","tutorial","Blog-post"],"image":{"childImageSharp":{"fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAwACBf/EABUBAQEAAAAAAAAAAAAAAAAAAAME/9oADAMBAAIQAxAAAAHmKhVqNiIf/8QAGRAAAwEBAQAAAAAAAAAAAAAAAAECEQMS/9oACAEBAAEFAp5ukoNFqn0kOj//xAAWEQEBAQAAAAAAAAAAAAAAAAACEEH/2gAIAQMBAT8BIOz/xAAYEQACAwAAAAAAAAAAAAAAAAACAxARMf/aAAgBAgEBPwFp3kf/xAAaEAACAgMAAAAAAAAAAAAAAAABEABBAhEh/9oACAEBAAY/At1OFHKn/8QAGBABAQEBAQAAAAAAAAAAAAAAAREAITH/2gAIAQEAAT8hjchnXVGFDMsQ1BmrFmRfN//aAAwDAQACAAMAAAAQdx//xAAYEQEBAAMAAAAAAAAAAAAAAAABABEhwf/aAAgBAwEBPxARh8kB03//xAAXEQEBAQEAAAAAAAAAAAAAAAABACFB/9oACAECAQE/EBNzpf/EABsQAQEAAwADAAAAAAAAAAAAAAERACExUXHB/9oACAEBAAE/EGMFBC313DC7mdV+YrJJ57hMGYE7HBfCt0buFoACAHM//9k=","aspectRatio":1.3333333333333333,"src":"/static/1a3dc0006a5adae718d145990e724821/b326b/tiva-launchpad-header.jpg","srcSet":"/static/1a3dc0006a5adae718d145990e724821/4018e/tiva-launchpad-header.jpg 930w,\n/static/1a3dc0006a5adae718d145990e724821/88222/tiva-launchpad-header.jpg 1860w,\n/static/1a3dc0006a5adae718d145990e724821/b326b/tiva-launchpad-header.jpg 3264w","sizes":"(max-width: 3264px) 100vw, 3264px"}}},"author":{"id":"Richard","bio":"Mechatronics Systems engineering student passionate about space, interested in high-reliability embedded systems and computer vision. Currently turning coffee into CubeSats and drones.","avatar":{"children":[{"__typename":"ImageSharp","fixed":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAIDBAX/xAAVAQEBAAAAAAAAAAAAAAAAAAABAP/aAAwDAQACEAMQAAAB589OeKWwkKgbQn//xAAbEAACAwADAAAAAAAAAAAAAAABAgASIREiMf/aAAgBAQABBQKE9YzUFt5h1V0n3//EABURAQEAAAAAAAAAAAAAAAAAAAEQ/9oACAEDAQE/ASE//8QAFREBAQAAAAAAAAAAAAAAAAAAESD/2gAIAQIBAT8BY//EABoQAAICAwAAAAAAAAAAAAAAAAABESEQIDH/2gAIAQEABj8CFHcUrJ1//8QAGhABAAMBAQEAAAAAAAAAAAAAAQARIUExEP/aAAgBAQABPyG1c2E0Ipg9xPQFJ35HtxipKNj1P//aAAwDAQACAAMAAAAQkxCD/8QAGBEAAgMAAAAAAAAAAAAAAAAAABEBECH/2gAIAQMBAT8Q0xkK/8QAGBEAAgMAAAAAAAAAAAAAAAAAAAEQEUH/2gAIAQIBAT8Qs4WiP//EABwQAQADAAMBAQAAAAAAAAAAAAEAESExQXFhkf/aAAgBAQABPxCgAp6NYEcIGjV7i+0/kFpV61wTiYFlNYhBTUGAHzHlQFSFqER9qn//2Q==","width":400,"height":400,"src":"/static/a2b7322425489e49016cd6942dbb87ef/2e811/richard.jpg","srcSet":"/static/a2b7322425489e49016cd6942dbb87ef/2e811/richard.jpg 1x"}}]}}}},"relatedPosts":{"totalCount":3,"edges":[{"node":{"id":"9c280710-4b19-5dea-ae81-49819aaf7458","timeToRead":3,"excerpt":"TI locks some GPIO pins because they’re required for programming interfaces like JTAG. SW2 on the LaunchPad is connected to PF0 ( page 33…","frontmatter":{"title":"TI ARM LaunchPad GPIO Unlock Tutorial"},"fields":{"slug":"/posts/ti-launchpad-gpio-unlock/"}}},{"node":{"id":"62dce9aa-62b4-5e97-8eb6-2fefc7ea5017","timeToRead":6,"excerpt":"The TI Tiva Launchpad boards are an excellent way to get started working with ARM microcontrollers. With the Tivaware software suite, they…","frontmatter":{"title":"TI ARM LaunchPad GPIO Input Tutorial"},"fields":{"slug":"/posts/ti-launchpad-gpio-input/"}}},{"node":{"id":"02856b9a-5f4b-54b2-9e79-e36fa544eb9c","timeToRead":4,"excerpt":"The GPIO functions in Tivaware take a little fiddling with to understand. For beginners, it may not be immediately obvious what’s going on…","frontmatter":{"title":"TI ARM LaunchPad GPIO Output Tutorial"},"fields":{"slug":"/posts/ti-launchpad-gpio-output/"}}}]}},"pageContext":{"slug":"/posts/ti-launchpad-gpio-input/","prev":{"excerpt":"TI locks some GPIO pins because they’re required for programming interfaces like JTAG. SW2 on the LaunchPad is connected to PF0 ( page 33…","timeToRead":3,"frontmatter":{"title":"TI ARM LaunchPad GPIO Unlock Tutorial","tags":["microcontroller","TI","ARM","tutorial","Blog-post"],"date":"2015-05-25T00:00:00.000Z","image":{"childImageSharp":{"fluid":{"aspectRatio":1.5609756097560976,"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAIDBAX/xAAVAQEBAAAAAAAAAAAAAAAAAAABAv/aAAwDAQACEAMQAAABzFmcqsOD/8QAGBABAQEBAQAAAAAAAAAAAAAAAQASAiH/2gAIAQEAAQUCQTNnqJvL/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFREBAQAAAAAAAAAAAAAAAAAAARD/2gAIAQIBAT8BCf/EABgQAAMBAQAAAAAAAAAAAAAAAAARMSAh/9oACAEBAAY/Am+lxD//xAAbEAEAAgIDAAAAAAAAAAAAAAABABEhYTFR8P/aAAgBAQABPyFSidKh6qbCZAblK4jlH//aAAwDAQACAAMAAAAQSy//xAAVEQEBAAAAAAAAAAAAAAAAAAABEP/aAAgBAwEBPxBZ/8QAFhEAAwAAAAAAAAAAAAAAAAAAARAR/9oACAECAQE/EIBf/8QAHxAAAQIGAwAAAAAAAAAAAAAAAQARITFRgZGh0eHw/9oACAEBAAE/EAwgzNR0gkOPVwqGftOOGAAzOEQVU9I1wv/Z","sizes":"(max-width: 3264px) 100vw, 3264px","src":"/static/dbb6f3697ea5cc34753ab1d6f1c08a2d/b326b/tiva-launchpad-unlock.jpg","srcSet":"/static/dbb6f3697ea5cc34753ab1d6f1c08a2d/4018e/tiva-launchpad-unlock.jpg 930w,\n/static/dbb6f3697ea5cc34753ab1d6f1c08a2d/88222/tiva-launchpad-unlock.jpg 1860w,\n/static/dbb6f3697ea5cc34753ab1d6f1c08a2d/b326b/tiva-launchpad-unlock.jpg 3264w"}}},"author":{"id":"Richard","bio":"Mechatronics Systems engineering student passionate about space, interested in high-reliability embedded systems and computer vision. Currently turning coffee into CubeSats and drones.","avatar":{"children":[{"fixed":{"src":"/static/a2b7322425489e49016cd6942dbb87ef/2e811/richard.jpg"}}]}}},"fields":{"layout":"","slug":"/posts/ti-launchpad-gpio-unlock/"}},"next":{"excerpt":"The GPIO functions in Tivaware take a little fiddling with to understand. For beginners, it may not be immediately obvious what’s going on…","timeToRead":4,"frontmatter":{"title":"TI ARM LaunchPad GPIO Output Tutorial","tags":["microcontroller","TI","ARM","tutorial","Blog-post"],"date":"2015-05-25T00:00:00.000Z","image":{"childImageSharp":{"fluid":{"aspectRatio":1.3333333333333333,"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAQCA//EABYBAQEBAAAAAAAAAAAAAAAAAAQABf/aAAwDAQACEAMQAAABj1xTLEB2f//EABsQAAEEAwAAAAAAAAAAAAAAAAEAAgMRIUFC/9oACAEBAAEFAusU5sS0Lolf/8QAGBEAAwEBAAAAAAAAAAAAAAAAAAIRAzL/2gAIAQMBAT8Bg2TXo//EABgRAAMBAQAAAAAAAAAAAAAAAAABAhED/9oACAECAQE/AYePRdZP/8QAGRAAAgMBAAAAAAAAAAAAAAAAAAEQISNB/9oACAEBAAY/AqhacEXH/8QAGBAAAwEBAAAAAAAAAAAAAAAAAAERMUH/2gAIAQEAAT8hfVJPBKjWk3bRSlDVknh//9oADAMBAAIAAwAAABA7D//EABoRAAICAwAAAAAAAAAAAAAAAAABESExgaH/2gAIAQMBAT8QeCjZI24f/8QAGREAAwADAAAAAAAAAAAAAAAAAAERMaHR/9oACAECAQE/EE0EGXrh/8QAGxABAAMBAAMAAAAAAAAAAAAAAQARITFBcaH/2gAIAQEAAT8QfatgfkpxTEvIC1CLg7bFWDT4iFoL9QhG2T//2Q==","sizes":"(max-width: 3264px) 100vw, 3264px","src":"/static/499f888b5cc05de8f7dbe315803ec5ff/b326b/tiva-launchpad-header-3.jpg","srcSet":"/static/499f888b5cc05de8f7dbe315803ec5ff/4018e/tiva-launchpad-header-3.jpg 930w,\n/static/499f888b5cc05de8f7dbe315803ec5ff/88222/tiva-launchpad-header-3.jpg 1860w,\n/static/499f888b5cc05de8f7dbe315803ec5ff/b326b/tiva-launchpad-header-3.jpg 3264w"}}},"author":{"id":"Richard","bio":"Mechatronics Systems engineering student passionate about space, interested in high-reliability embedded systems and computer vision. Currently turning coffee into CubeSats and drones.","avatar":{"children":[{"fixed":{"src":"/static/a2b7322425489e49016cd6942dbb87ef/2e811/richard.jpg"}}]}}},"fields":{"layout":"","slug":"/posts/ti-launchpad-gpio-output/"}},"primaryTag":"microcontroller"}}